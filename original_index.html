<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravitas - Web Black Hole Sandbox</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Roboto+Mono:wght@400;700&display=swap');

		/* ===== Splash screen ===== */
		#splash{
			position:fixed;
			inset:0;                    /* top:0; right:0; bottom:0; left:0 */
			display:flex;
			align-items:center;
			justify-content:center;
			background:var(--bg-color);
			z-index:3000;               /* above every UI element */
			opacity:0;
			animation:
				splashFadeIn   1.6s   ease-out   0s   forwards,
				splashFadeOut  1.2s   ease-in    2.3s forwards;
		}
		
		/* Hide UI elements during splash screen */
		.ui-container, #overlay, #scenarioInfoDisplay {
			opacity: 0;
			transition: opacity 1.0s ease-in;
		}
		
		/* Show UI elements after splash */
		.ui-container.showUI, #overlay.showUI, #scenarioInfoDisplay.showUI {
			opacity: 1;
		}
		#splash h1{
			margin:0;
			font-family:'Poppins',sans-serif;
			font-weight:600;
			font-size: clamp(4rem, 8vw, 8rem);
			letter-spacing:0.12em;
			color:var(--primary-color);
			text-shadow:0 0 25px var(--primary-color);
			opacity: 0;
			animation: logoFadeIn 1.0s ease-out 0.3s forwards;
		}
		
		@keyframes logoFadeIn {
			from { opacity: 0; transform: scale(0.9); }
			to { opacity: 1; transform: scale(1.0); }
		}

		/*  hidden until JS adds .showCanvas  */
		#simulationCanvas, #starfieldCanvas {
			opacity:0;              /* fully transparent       */
			visibility:hidden;      /* not rendered at all     */
			transition:opacity 1.2s ease-in;  /* fade-in only */
		}

		/*  added by JS after splash is gone  */
		#simulationCanvas.showCanvas, #starfieldCanvas.showCanvas {
			visibility:visible;     /* render now              */
			opacity:1;              /* and fade up to opaque   */
		}


		/* --- keyframes --- */
		@keyframes splashFadeIn  { 
			from { opacity: 0; } 
			to { opacity: 1; } 
		}
		@keyframes splashFadeOut { 
			from { opacity: 1; } 
			to { opacity: 0; } 
		}


        :root {
            --bg-color: #0d0d1a;
            --text-color: #e0e0e0;
            --primary-color: #00aaff;
            --secondary-color: #ffaa00;
            --panel-bg: rgba(20, 20, 40, 0.95);
            --button-bg: #333;
            --button-hover-bg: #555;
            --button-apply-bg: #28a745;
            --button-apply-hover-bg: #218838;
            --separator-color: #00aaff80;
        }

		/* === layered canvases === */
		.sim-canvas{
			position:fixed; inset:0;
			width:100%; height:100%;
			display:block;
		}
		#starfieldCanvas{ z-index:1; }   /* back-most */
		#simulationCanvas{ z-index:2; }  /* front */


        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
        }
        
        /* Ensure clean splash screen start */
        html, body {
            background-color: var(--bg-color);
        }

        #simulationCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #overlay {
            position: fixed;
            top: 15px;
            left: 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            color: #ccc;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            line-height: 1.5;
            z-index: 10;
        }

        #scenarioInfoDisplay {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            padding: 10px 20px;
            background: var(--panel-bg);
            border: 1px solid var(--separator-color);
            border-radius: 8px;
            text-align: center;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #scenarioInfoDisplay.visible {
            opacity: 1;
        }
        #scenarioInfoDisplay h4 {
            margin: 0 0 5px 0;
            font-size: 18px;
            color: var(--primary-color);
            font-weight: 600;
        }
        #scenarioInfoDisplay p {
            margin: 0;
            font-size: 14px;
            color: var(--text-color);
            line-height: 1.4;
        }

        /* Object Inspector Modal */
        #objectInspector {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background: rgba(13, 13, 26, 0.95);
            backdrop-filter: blur(20px);
            border: 2px solid var(--primary-color);
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(0, 170, 255, 0.3);
            z-index: 2000;
            display: none;
            padding: 25px;
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
        }

        #objectInspector.visible {
            display: block;
            animation: inspectorFadeIn 0.3s ease-out;
        }

        @keyframes inspectorFadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }
        }

        .inspector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--separator-color);
        }

        .inspector-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--primary-color);
            margin: 0;
        }

        .inspector-close {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: all 0.2s ease;
        }

        .inspector-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--primary-color);
        }

        .inspector-content {
            line-height: 1.6;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 12px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 170, 255, 0.1);
        }

        .stat-label {
            font-weight: 500;
            color: var(--secondary-color);
        }

        .stat-value {
            font-family: 'Roboto Mono', monospace;
            color: var(--text-color);
            text-align: right;
        }

        .object-description {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 170, 255, 0.1);
            border-radius: 8px;
            border-left: 3px solid var(--primary-color);
            font-style: italic;
        }

        .object-icon {
            font-size: 32px;
            margin-right: 15px;
        }


        .ui-container {
            position: fixed;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        /* Mobile-friendly UI adjustments */
        @media (max-width: 768px) {
            .ui-container {
                top: 10px;
                right: 10px;
                gap: 8px;
            }
            
            .ui-button {
                padding: 12px 16px;
                font-size: 16px;
                min-height: 44px; /* iOS minimum touch target */
            }
            
            .speed-controls {
                padding: 10px 14px;
            }
            
            .speed-btn {
                padding: 8px 14px;
                font-size: 14px;
                min-width: 70px;
            }
            
            #settingsPanel {
                width: 95%;
                max-width: none;
                height: 95vh;
                max-height: none;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
                gap: 15px 20px;
            }
            
                    .setting-label {
            justify-self: start;
            text-align: left;
        }
        
        #mobileInstructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(13, 13, 26, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 170, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            z-index: 2000;
            max-width: 300px;
            text-align: center;
        }
        
        .mobile-instructions-content h3 {
            margin: 0 0 15px 0;
            color: var(--primary-color);
            font-size: 18px;
        }
        
        .mobile-instructions-content p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        }

        .ui-button {
            padding: 8px 16px;
            background-color: var(--button-bg);
            color: var(--text-color);
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            transition: background-color 0.2s ease, transform 0.1s ease;
            text-align: center;
        }

        .ui-button:hover {
            background-color: var(--button-hover-bg);
        }
        .ui-button:active {
            transform: scale(0.98);
        }

        .speed-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(20, 20, 40, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(0, 170, 255, 0.3);
        }

        .speed-btn {
            padding: 6px 12px;
            font-size: 12px;
            min-width: 60px;
        }

        .speed-display {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-color);
            min-width: 50px;
            text-align: center;
            font-weight: bold;
        }

        #settingsPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            height: 90vh;
            max-height: 850px;
            background: rgba(13, 13, 26, 0.85);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(0, 170, 255, 0.2);
            border-radius: 20px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 0 1px rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #settingsPanel.hidden {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
            pointer-events: none;
            filter: blur(10px);
        }

        .settings-header {
            padding: 25px 30px;
            text-align: center;
            font-size: 28px;
            font-weight: 600;
            color: var(--primary-color);
            background: linear-gradient(135deg, rgba(0, 170, 255, 0.1), rgba(0, 170, 255, 0.05));
            border-bottom: 1px solid rgba(0, 170, 255, 0.2);
            border-radius: 20px 20px 0 0;
            text-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }

        .settings-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 25px 35px;
            background: rgba(0, 0, 0, 0.1);
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px 35px;
            align-items: center;
        }
        
        .setting-item, .setting-special-button {
            display: contents;
        }
        
        .setting-label {
            justify-self: end;
            text-align: right;
            font-size: 15px;
            color: rgba(224, 224, 224, 0.9);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .setting-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .setting-control input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: linear-gradient(90deg, rgba(0, 170, 255, 0.3), rgba(0, 170, 255, 0.1));
            border-radius: 10px;
            outline: none;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .setting-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, var(--primary-color), #0088cc);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 
                0 2px 8px rgba(0, 170, 255, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: all 0.2s ease;
        }
        .setting-control input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 
                0 4px 12px rgba(0, 170, 255, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }
        .setting-control .value-display {
            min-width: 60px;
            text-align: left;
            font-family: 'Roboto Mono', monospace;
            color: rgba(224, 224, 224, 0.9);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .setting-control select, .setting-control .toggle-button {
            width: 100%;
            padding: 10px 12px;
            background: rgba(34, 34, 34, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 170, 255, 0.3);
            color: var(--text-color);
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        .setting-control select:hover, .setting-control .toggle-button:hover {
            background: rgba(44, 44, 44, 0.9);
            border-color: rgba(0, 170, 255, 0.5);
            transform: translateY(-1px);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        .setting-control select:focus, .setting-control .toggle-button:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 
                0 0 0 3px rgba(0, 170, 255, 0.2),
                0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .setting-control input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 50px;
            height: 30px;
            background-color: transparent;
            border: 2px solid rgba(0, 170, 255, 0.3);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .setting-control input[type="color"]:hover {
            border-color: rgba(0, 170, 255, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .setting-control input[type="color"]::-webkit-color-swatch {
            border-radius: 6px;
            border: none;
        }

        .setting-separator {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
        }
        .setting-separator h3 {
            margin: 0;
            color: var(--secondary-color);
            font-size: 18px;
            white-space: nowrap;
            text-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
        }
        .setting-separator .line {
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--separator-color), transparent);
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }

        .settings-footer {
            padding: 25px 30px;
            display: flex;
            justify-content: center;
            gap: 15px;
            background: linear-gradient(135deg, rgba(0, 170, 255, 0.05), rgba(0, 170, 255, 0.1));
            border-top: 1px solid rgba(0, 170, 255, 0.2);
            border-radius: 0 0 20px 20px;
        }
        
        .footer-button {
            padding: 12px 28px;
            font-size: 16px;
            background: rgba(40, 40, 40, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 170, 255, 0.3);
            border-radius: 10px;
            transition: all 0.3s ease;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        .footer-button:hover {
            background: rgba(50, 50, 50, 0.9);
            border-color: rgba(0, 170, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        #settingsApply { 
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.8), rgba(40, 167, 69, 0.6));
            border-color: rgba(40, 167, 69, 0.4);
        }
        #settingsApply:hover { 
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.9), rgba(40, 167, 69, 0.7));
            border-color: rgba(40, 167, 69, 0.6);
        }

        #bhMassesModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 450px;
            background-color: var(--panel-bg);
            border: 1px solid var(--primary-color);
            border-radius: 10px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.7);
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        #bhMassesModal.hidden { display: none; }
        .bh-masses-header { text-align: center; padding: 15px; font-size: 20px; color: var(--primary-color); }
        .bh-masses-content { 
            padding: 20px 30px; 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            max-height: 50vh; 
            overflow-y: auto; 
        }
        .bh-mass-item { 
            display: grid;
            grid-template-columns: 1fr 2fr;
            align-items: center;
            gap: 15px;
        }
        .bh-mass-item label {
            justify-self: end;
            text-align: right;
        }
        .bh-mass-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .bh-mass-control input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: #444;
            border-radius: 5px;
            outline: none;
        }
        .bh-mass-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }
        .bh-mass-control .value-display {
            min-width: 60px;
            text-align: left;
            font-family: 'Roboto Mono', monospace;
        }
        .bh-masses-footer { padding: 15px; text-align: center; }

		/* --- Preset title / summary box --- */
		.preset-info{
			margin:18px 0 10px;
			padding:12px 16px;
			background:rgba(0,0,0,.25);
			border:1px solid var(--separator-color);
			border-radius:6px;
			font-size:14px;
			line-height:1.4;
		}
		.preset-info h4{
			margin:0 0 4px;
			font-size:17px;
			color:var(--primary-color);
		}

    </style>
</head>
<body>
    <canvas id="starfieldCanvas" class="sim-canvas"></canvas>
	<canvas id="simulationCanvas" class="sim-canvas"></canvas>

    <!-- ✨ Splash screen -->
	<div id="splash">
	  <h1>GRAVITAS</h1>
	</div>

    <div id="overlay"></div>
    <div id="scenarioInfoDisplay"></div>
    <div id="mobileInstructions" style="display: none;">
        <div class="mobile-instructions-content">
            <h3>Mobile Controls</h3>
            <p>• <strong>Single tap & drag:</strong> Add object with velocity</p>
            <p>• <strong>Drag without adding:</strong> Pan the view</p>
            <p>• <strong>Pinch:</strong> Zoom in/out</p>
            <p>• <strong>Double tap:</strong> Reset view</p>
        </div>
    </div>

    <div class="ui-container">
        <button id="settingsBtn" class="ui-button">Settings</button>
        <button id="refreshScenarioBtn" class="ui-button">Refresh Scenario</button>
        <button id="resetAllBtn" class="ui-button">Reset to Default</button>
        <button id="saveBtn" class="ui-button">Save State</button>
        <button id="loadBtn" class="ui-button">Load State</button>
        <button id="screenshotBtn" class="ui-button" title="Take a screenshot (or press P)">📸 Screenshot</button>
        
        <div class="speed-controls">
            <button id="slowDownBtn" class="ui-button speed-btn">⏪ Slow</button>
            <span id="speedDisplay" class="speed-display">1.0x</span>
            <button id="speedUpBtn" class="ui-button speed-btn">Fast ⏩</button>
        </div>
        
        <button id="resetViewBtn" class="ui-button">Reset View</button>
        <button id="objectTypeBtn" class="ui-button primary" title="Click to change what type of object you insert">⭐ Add Stars</button>
    </div>

    <div id="settingsPanel" class="hidden">
        <div class="settings-header">Simulation Settings</div>
        <div class="settings-content">
        <div id="presetInfo" class="preset-info"></div>

            <div id="settingsGrid" class="settings-grid"></div>
        </div>
        <div class="settings-footer">
            <button id="settingsApply" class="ui-button footer-button">Apply & Restart</button>
            <button id="settingsReset" class="ui-button footer-button">Reset to Defaults</button>
            <button id="settingsCancel" class="ui-button footer-button">Cancel</button>
        </div>
    </div>

    <div id="bhMassesModal" class="hidden">
        <div class="bh-masses-header">Set Individual Black Hole Masses (M<sub>sun</sub>)</div>
        <div id="bhMassesContent" class="bh-masses-content"></div>
        <div class="bh-masses-footer">
            <button id="bhMassesDone" class="ui-button">Done</button>
        </div>
    </div>

    <!-- Object Inspector Modal -->
    <div id="objectInspector">
        <div class="inspector-header">
            <h3 class="inspector-title" id="inspectorTitle">Object Details</h3>
            <button class="inspector-close" id="inspectorClose">&times;</button>
        </div>
        <div class="inspector-content" id="inspectorContent">
            <!-- Content will be populated by JavaScript -->
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {

    const canvas = document.getElementById('simulationCanvas');
	// ---------- star-field layer ----------
	const starfieldCanvas = document.getElementById('starfieldCanvas');
	const starCtx         = starfieldCanvas.getContext('2d');
	const star_field = [];

	const splash = document.getElementById('splash');

	/*  nothing to show at first ↓  */
	canvas.classList.remove('showCanvas');
    starfieldCanvas.classList.remove('showCanvas');

	splash.addEventListener('animationend', (e) => {
		if (e.animationName === 'splashFadeOut') {
			splash.remove();                 // splash done
			canvas.classList.add('showCanvas');  // NOW fade the sim in
            starfieldCanvas.classList.add('showCanvas');
            
            // Show UI elements after a short delay
            setTimeout(() => {
                document.querySelector('.ui-container').classList.add('showUI');
                document.getElementById('overlay').classList.add('showUI');
                document.getElementById('scenarioInfoDisplay').classList.add('showUI');
                
                // Show scenario info after UI elements are visible
                setTimeout(() => {
                    show_scenario_info();
                }, 500);
            }, 200);
		}
	});

    const createAmbientGradient = () => {
        const grad = starCtx.createLinearGradient(0, 0, 0, starfieldCanvas.height);
        grad.addColorStop(0, '#1a1a3a');
        grad.addColorStop(1, '#0a0a1a');
        return grad;
    }

	function generateStarfield(){
		star_field.length = 0;
		const num = SETTINGS.star_density;
		const W = starfieldCanvas.width  * 2;
		const H = starfieldCanvas.height * 2;
		for(let i=0;i<num;i++){
			star_field.push({
				x: Math.random()*W - W/2,
				y: Math.random()*H - H/2,
				b: Math.random()*0.7 + 0.3,
				s: Math.random()*1.5 + 0.5
			});
		}
		drawStarfield();
	}

	function drawStarfield(){
        starCtx.fillStyle = SETTINGS.show_ambient_lighting ? createAmbientGradient() : '#0d0d1a';
        starCtx.fillRect(0,0,starfieldCanvas.width,starfieldCanvas.height);

		star_field.forEach(st=>{
			starCtx.globalAlpha = st.b;
			starCtx.fillStyle   = '#fff';
			starCtx.fillRect(
				st.x + starfieldCanvas.width/2,
				st.y + starfieldCanvas.height/2,
				st.s, st.s
			);
		});
		starCtx.globalAlpha = 1;
	}


    const ctx = canvas.getContext('2d');
    if (!ctx) {
        alert('Error: Could not get 2D context. Your browser may not support canvas.');
        return;
    }
    
    const overlayDiv = document.getElementById('overlay');
    const settingsPanel = document.getElementById('settingsPanel');
    const settingsGrid = document.getElementById('settingsGrid');
    const bhMassesModal = document.getElementById('bhMassesModal');
    const objectInspector = document.getElementById('objectInspector');
    const inspectorTitle = document.getElementById('inspectorTitle');
    const inspectorContent = document.getElementById('inspectorContent');

    const DT = 0.1;
    const SOLAR_MASS_UNIT = 1000;
    const ABSORB_BUFFER = 6;
    const MIN_INTERACTION_DISTANCE = 5.0;
    const SAVE_KEY = "gravitas_simulation_save";
    const BH_RADIUS_BASE = 15;
    const PLANET_RADIUS = 5;
    const GAS_GIANT_RADIUS = 12; // Reduced from 15
    const ASTEROID_RADIUS = 2;
    const STAR_OBJ_RADIUS = 15; // Increased from 10 to make stars larger
    const DEBRIS_RADIUS = 2;
    const MAX_STAR_MASS_BEFORE_BH = 20.0; // Stars above this mass (in solar masses) become black holes

    const DEFAULT_SETTINGS = {
        preset_scenario: "Binary BH", 
        gravitational_constant: 2.0,  
        follow_mode: "BlackHole",       
        num_planets: 15, num_gas_giants: 2, init_velocity: 20, velocity_stddev: 5,
        bh_mass: 10, num_black_holes: 1, bh_behavior: "Static", use_individual_bh_masses: false,
        bh_masses: [], orbit_decay_rate: 0.005, placement: "Random", 
        mutual_gravity: false,
        show_trails: true,
        sim_speed: 1.0,
        show_velocity_vectors: false, interactive_add: true, trail_length: 15,
        trail_style: "Glow",
        sim_size: "Large", 
        star_density: 10000,
        input_object_type: "Star", show_bh_glow: true,
        show_accretion_disk: true, show_bh_jets: false, improved_lensing: true, lensing_strength: 100,
        show_dynamic_overlays: true, enable_asteroids: true, num_asteroids: 10,
        dynamic_object_properties: true, record_simulation: false, 
        show_ambient_lighting: true,
        planet_base_color: "#6495ed", 
        star_base_color: "#ffff00",
        enable_star_merging: true,
        max_star_mass_before_bh: 20.0,  
    };
    let SETTINGS = { ...DEFAULT_SETTINGS };
    let localSettings = {};

    let state = {
        zoom: 1.0, pan: { x: 0.0, y: 0.0 }, paused: false, frame_count: 0,
        mouse: { x: 0, y: 0, down: false }, adding_mass: false,
        add_start_screen: { x: 0, y: 0 }, add_start_world: { x: 0, y: 0 },
        touch_active: false, touch_id: null,
        last_time: 0,
        inspector_open: false,
    };

    let bh_list = [], planets = [], stars = [], gas_giants = [], asteroids = [],
        debris = [], particles = [], gwaves = [], gravity_ripples = [];
    
    let PhysicsObject_id_counter = 0;



    const world_to_screen = (pos) => ({ x: pos.x, y: pos.y });

    const screen_to_world = (spos) => ({
        x: (spos.x - canvas.width / 2 - state.pan.x) / state.zoom,
        y: -(spos.y - canvas.height / 2 - state.pan.y) / state.zoom
    });

    const is_offscreen = (pos, buffer_factor = 1.5) => {
        const half_width_world = (canvas.width / (2 * state.zoom)) * buffer_factor;
        const half_height_world = (canvas.height / (2 * state.zoom)) * buffer_factor;
        const world_center_x = -state.pan.x / state.zoom;
        const world_center_y = state.pan.y / state.zoom;
        return (pos.x < world_center_x - half_width_world ||
                pos.x > world_center_x + half_width_world ||
                pos.y < world_center_y - half_height_world ||
                pos.y > world_center_y + half_height_world);
    }
    
    const hexToRgb = (hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
    }

    const compute_dynamic_color = (base_color_hex, pos, bh_list, threshold = 300.0, target_color = {r:255, g:0, b:0}) => {
        if (!bh_list || bh_list.length === 0 || !SETTINGS.dynamic_object_properties) return base_color_hex;
        let min_dist_sq = Infinity;
        for (const bh of bh_list) {
            const dx = pos.x - bh.pos.x;
            const dy = pos.y - bh.pos.y;
            min_dist_sq = Math.min(min_dist_sq, dx*dx + dy*dy);
        }
        const f = Math.max(0.0, Math.min(1.0, (threshold - Math.sqrt(min_dist_sq)) / threshold));
        const base_color = hexToRgb(base_color_hex);
        if (!base_color) return base_color_hex;
        const r = Math.round(base_color.r * (1 - f) + target_color.r * f);
        const g = Math.round(base_color.g * (1 - f) + target_color.g * f);
        const b = Math.round(base_color.b * (1 - f) + target_color.b * f);
        return `rgb(${r},${g},${b})`;
    }

    const gravitational_acceleration = (target_pos, sources) => {
        let ax = 0.0, ay = 0.0;
        const G_val = SETTINGS.gravitational_constant;
        for (const s of sources) {
            const dx = s.pos.x - target_pos.x;
            const dy = s.pos.y - target_pos.y;
            let r_sq = dx*dx + dy*dy;
            if (r_sq < MIN_INTERACTION_DISTANCE**2) r_sq = MIN_INTERACTION_DISTANCE**2;
            const r = Math.sqrt(r_sq);
            if (r === 0) continue;
            const a_mag = G_val * s.mass / r_sq;
            ax += a_mag * (dx / r);
            ay += a_mag * (dy / r);
        }
        return { ax, ay };
    };

    // Object inspection functions
    const findObjectAtPosition = (worldPos) => {
        // Check black holes first (they're usually the most important)
        for (const bh of bh_list) {
            const dx = worldPos.x - bh.pos.x;
            const dy = worldPos.y - bh.pos.y;
            const clickRadius = Math.max(bh.radius, 10 / state.zoom); // Use actual radius or minimum clickable size
            if (dx*dx + dy*dy < clickRadius*clickRadius) {
                return { object: bh, type: 'BlackHole' };
            }
        }
        
        // Check stars (including neutron stars and white dwarfs)
        for (const star of stars) {
            if (!star.alive) continue;
            const dx = worldPos.x - star.pos.x;
            const dy = worldPos.y - star.pos.y;
            const clickRadius = Math.max(star.radius, 8 / state.zoom); // Use actual radius or minimum clickable size
            if (dx*dx + dy*dy < clickRadius*clickRadius) {
                // Determine the specific type based on the object's class
                if (star instanceof NeutronStar) {
                    return { object: star, type: 'NeutronStar' };
                } else if (star instanceof WhiteDwarf) {
                    return { object: star, type: 'WhiteDwarf' };
                } else {
                    return { object: star, type: 'Star' };
                }
            }
        }
        
        // Check gas giants
        for (const gasGiant of gas_giants) {
            if (!gasGiant.alive) continue;
            const dx = worldPos.x - gasGiant.pos.x;
            const dy = worldPos.y - gasGiant.pos.y;
            const clickRadius = Math.max(gasGiant.radius, 8 / state.zoom); // Use actual radius or minimum clickable size
            if (dx*dx + dy*dy < clickRadius*clickRadius) {
                return { object: gasGiant, type: 'GasGiant' };
            }
        }
        
        // Check planets
        for (const planet of planets) {
            if (!planet.alive) continue;
            const dx = worldPos.x - planet.pos.x;
            const dy = worldPos.y - planet.pos.y;
            const clickRadius = Math.max(planet.radius, 6 / state.zoom); // Use actual radius or minimum clickable size
            if (dx*dx + dy*dy < clickRadius*clickRadius) {
                return { object: planet, type: 'Planet' };
            }
        }
        
        // Check asteroids (including comets)
        for (const asteroid of asteroids) {
            if (!asteroid.alive) continue;
            const dx = worldPos.x - asteroid.pos.x;
            const dy = worldPos.y - asteroid.pos.y;
            const clickRadius = Math.max(asteroid.radius, 4 / state.zoom); // Use actual radius or minimum clickable size
            if (dx*dx + dy*dy < clickRadius*clickRadius) {
                // Determine if it's a comet or regular asteroid
                if (asteroid instanceof Comet) {
                    return { object: asteroid, type: 'Comet' };
                } else {
                    return { object: asteroid, type: 'Asteroid' };
                }
            }
        }
        
        return null;
    };

    const getBlackHoleInfo = (bh) => {
        const massInSuns = bh.mass / SOLAR_MASS_UNIT;
        const massInKg = massInSuns * 1.989e30;
        
        // Real Schwarzschild radius calculation (in meters)
        const G = 6.67430e-11; // Gravitational constant in m³/kg/s²
        const c = 299792458; // Speed of light in m/s
        const schwarzschildRadiusM = (2 * G * massInKg) / (c * c);
        const schwarzschildRadiusKm = schwarzschildRadiusM / 1000;
        const schwarzschildRadiusAU = schwarzschildRadiusM / 1.496e11; // 1 AU in meters
        
        // Real escape velocity at Schwarzschild radius (should be c)
        const escapeVelocityAtRs = Math.sqrt((2 * G * massInKg) / schwarzschildRadiusM);
        const escapeVelocityAtRsC = (escapeVelocityAtRs / c) * 100; // As percentage of light speed
        
        // Real density calculation (mass within Schwarzschild radius)
        const volume = (4/3) * Math.PI * Math.pow(schwarzschildRadiusM, 3);
        const density = massInKg / volume; // kg/m³
        
        // Hawking temperature (simplified)
        const hbar = 1.054571817e-34; // Reduced Planck constant
        const kB = 1.380649e-23; // Boltzmann constant
        const hawkingTemp = (hbar * c * c * c) / (8 * Math.PI * G * massInKg * kB);
        
        // Hawking radiation lifetime (simplified)
        const hawkingLifetime = (5120 * Math.PI * G * G * massInKg * massInKg * massInKg) / (hbar * c * c * c * c);
        const hawkingLifetimeYears = hawkingLifetime / (365.25 * 24 * 3600);
        
        // Real orbital period at 3 Schwarzschild radii (innermost stable orbit)
        const iscoRadius = 3 * schwarzschildRadiusM;
        const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(iscoRadius, 3) / (G * massInKg));
        const orbitalPeriodHours = orbitalPeriod / 3600;
        
        let bhType = 'Primordial';
        if (massInSuns > 1e6) bhType = 'Supermassive';
        else if (massInSuns > 100) bhType = 'Intermediate';
        else if (massInSuns > 3) bhType = 'Stellar-Mass';
        else bhType = 'Primordial';
        
        return {
            icon: '⚫',
            title: 'Black Hole',
            stats: [
                { label: 'Mass', value: `${massInSuns.toFixed(2)} M☉ (${massInKg.toExponential(2)} kg)` },
                { label: 'Schwarzschild Radius', value: `${schwarzschildRadiusKm.toFixed(2)} km (${schwarzschildRadiusAU.toExponential(3)} AU)` },
                { label: 'Escape Velocity at Rs', value: `${escapeVelocityAtRsC.toFixed(1)}% of light speed` },
                { label: 'Average Density', value: `${density.toExponential(2)} kg/m³` },
                { label: 'Hawking Temperature', value: `${hawkingTemp.toExponential(2)} K` },
                { label: 'Hawking Lifetime', value: hawkingLifetimeYears > 1e10 ? `${(hawkingLifetimeYears/1e9).toFixed(1)} billion years` : `${hawkingLifetimeYears.toExponential(2)} years` },
                { label: 'ISCO Period', value: `${orbitalPeriodHours.toFixed(1)} hours` },
                { label: 'Type', value: bhType },
                { label: 'Position', value: `(${bh.pos.x.toFixed(1)}, ${bh.pos.y.toFixed(1)})` },
                { label: 'Velocity', value: `${Math.hypot(bh.vel.x, bh.vel.y).toFixed(1)} units/s` }
            ],
            description: `A ${bhType.toLowerCase()} black hole with ${massInSuns > 1e6 ? 'enormous' : massInSuns > 100 ? 'substantial' : massInSuns > 3 ? 'moderate' : 'minimal'} mass. The event horizon has a radius of ${schwarzschildRadiusKm.toFixed(1)} km. ${hawkingTemp > 1 ? 'This black hole emits Hawking radiation.' : 'This black hole is too massive to emit significant Hawking radiation.'} ${massInSuns > 1e6 ? 'Supermassive black holes like this power active galactic nuclei and quasars.' : massInSuns > 100 ? 'Intermediate black holes are rare and may form from merging stellar-mass black holes.' : massInSuns > 3 ? 'Stellar-mass black holes form from the collapse of massive stars.' : 'Primordial black holes may have formed in the early universe.'}`
        };
    };

    const getStarInfo = (star) => {
        const massInSuns = star.massInSuns || (star.mass / SOLAR_MASS_UNIT);
        const radiusInSuns = star.radius / STAR_OBJ_RADIUS;
        const radiusInKm = radiusInSuns * 696340; // Solar radius in km
        const massInKg = massInSuns * 1.989e30; // Solar mass in kg
        
        // Real temperature estimate based on mass
        const temperature = 3000 + (massInSuns - 0.2) * 4000; // K
        
        // Real luminosity (W)
        const luminosity = Math.pow(massInSuns, 3.5) * 3.828e26; // Solar luminosity in W
        
        // Real surface gravity (m/s²)
        const G = 6.67430e-11;
        const surfaceGravity = (G * massInKg) / Math.pow(radiusInKm * 1000, 2);
        
        // Real escape velocity (m/s)
        const escapeVelocity = Math.sqrt((2 * G * massInKg) / (radiusInKm * 1000));
        
        // Real orbital period at 1 AU (if applicable)
        const distanceFromCenter = Math.hypot(star.pos.x, star.pos.y);
        const centralMass = 1000; // Assume central mass in simulation units
        const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(distanceFromCenter * 1e9, 3) / (G * centralMass * 1.989e30));
        const orbitalPeriodDays = orbitalPeriod / (24 * 3600);
        
        const age = Math.random() * 10; // Simulated age
        
        let spectralType = 'M';
        if (massInSuns > 2.1) spectralType = 'O';
        else if (massInSuns > 1.4) spectralType = 'B';
        else if (massInSuns > 1.04) spectralType = 'A';
        else if (massInSuns > 0.8) spectralType = 'F';
        else if (massInSuns > 0.45) spectralType = 'G';
        else if (massInSuns > 0.08) spectralType = 'K';
        
        return {
            icon: '⭐',
            title: 'Star',
            stats: [
                { label: 'Mass', value: `${massInSuns.toFixed(2)} M☉ (${massInKg.toExponential(2)} kg)` },
                { label: 'Radius', value: `${radiusInSuns.toFixed(2)} R☉ (${radiusInKm.toFixed(0)} km)` },
                { label: 'Temperature', value: `${temperature.toFixed(0)} K` },
                { label: 'Luminosity', value: `${(luminosity/1e26).toFixed(2)} × 10²⁶ W` },
                { label: 'Surface Gravity', value: `${surfaceGravity.toFixed(0)} m/s²` },
                { label: 'Escape Velocity', value: `${(escapeVelocity/1000).toFixed(1)} km/s` },
                { label: 'Spectral Type', value: spectralType },
                { label: 'Age', value: `${age.toFixed(1)} billion years` },
                { label: 'Orbital Period', value: orbitalPeriodDays > 365 ? `${(orbitalPeriodDays/365).toFixed(1)} years` : `${orbitalPeriodDays.toFixed(1)} days` },
                { label: 'Position', value: `(${star.pos.x.toFixed(1)}, ${star.pos.y.toFixed(1)})` },
                { label: 'Velocity', value: `${Math.hypot(star.vel.x, star.vel.y).toFixed(1)} units/s` }
            ],
            description: `A ${spectralType}-type star with ${massInSuns > 3 ? 'high' : massInSuns > 0.8 ? 'moderate' : 'low'} mass. ${massInSuns > 20 ? 'This massive star will likely end its life as a black hole.' : massInSuns > 8 ? 'This star will become a neutron star or black hole.' : 'This star will become a white dwarf.'}`
        };
    };

    const getPlanetInfo = (planet) => {
        const massInEarths = planet.massInEarths || (planet.mass / 1.0);
        const radiusInEarths = planet.radius / PLANET_RADIUS;
        const radiusInKm = radiusInEarths * 6371; // Earth radius in km
        const massInKg = massInEarths * 5.972e24; // Earth mass in kg
        
        // Real density calculation (kg/m³)
        const volume = (4/3) * Math.PI * Math.pow(radiusInKm * 1000, 3); // Convert km to m
        const density = massInKg / volume;
        
        // Real escape velocity (m/s)
        const G = 6.67430e-11; // Gravitational constant
        const escapeVelocity = Math.sqrt((2 * G * massInKg) / (radiusInKm * 1000));
        
        // Real orbital period (if orbiting a central mass)
        const distanceFromCenter = Math.hypot(planet.pos.x, planet.pos.y);
        const centralMass = 1000; // Assume central mass in simulation units
        const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(distanceFromCenter * 1e9, 3) / (G * centralMass * 1.989e30));
        const orbitalPeriodDays = orbitalPeriod / (24 * 3600);
        
        // Real surface gravity (m/s²)
        const surfaceGravity = (G * massInKg) / Math.pow(radiusInKm * 1000, 2);
        
        let planetType = 'Terrestrial';
        if (massInEarths > 10) planetType = 'Ice Giant';
        else if (massInEarths > 5) planetType = 'Gas Giant';
        else if (massInEarths > 0.5) planetType = 'Super-Earth';
        else planetType = 'Dwarf Planet';
        
        // Use the planet's actual density type if available
        const densityType = planet.density || 'rocky';
        let densityDescription = '';
        switch (densityType) {
            case 'gaseous':
                densityDescription = 'Gaseous composition with hydrogen and helium atmosphere';
                break;
            case 'icy':
                densityDescription = 'Icy composition with frozen volatiles';
                break;
            case 'rocky':
            default:
                densityDescription = 'Rocky composition with solid surface';
                break;
        }
        
        return {
            icon: '🪐',
            title: 'Planet',
            stats: [
                { label: 'Mass', value: `${massInEarths.toFixed(2)} M⊕ (${massInKg.toExponential(2)} kg)` },
                { label: 'Radius', value: `${radiusInEarths.toFixed(2)} R⊕ (${radiusInKm.toFixed(0)} km)` },
                { label: 'Density', value: `${density.toFixed(0)} kg/m³` },
                { label: 'Surface Gravity', value: `${surfaceGravity.toFixed(1)} m/s²` },
                { label: 'Escape Velocity', value: `${escapeVelocity.toFixed(0)} m/s` },
                { label: 'Orbital Period', value: orbitalPeriodDays > 365 ? `${(orbitalPeriodDays/365).toFixed(1)} years` : `${orbitalPeriodDays.toFixed(1)} days` },
                { label: 'Type', value: planetType },
                { label: 'Position', value: `(${planet.pos.x.toFixed(1)}, ${planet.pos.y.toFixed(1)})` },
                { label: 'Velocity', value: `${Math.hypot(planet.vel.x, planet.vel.y).toFixed(1)} units/s` }
            ],
            description: `A ${planetType.toLowerCase()} with ${massInEarths > 10 ? 'substantial' : massInEarths > 1 ? 'moderate' : 'low'} mass. ${densityDescription}. ${planetType === 'Terrestrial' ? 'This rocky world could potentially support life.' : planetType === 'Gas Giant' ? 'This gaseous planet has no solid surface.' : planetType === 'Ice Giant' ? 'This icy world is composed mainly of frozen volatiles.' : 'This small world may be a captured asteroid or dwarf planet.'}`
        };
    };

    const getGasGiantInfo = (gasGiant) => {
        const massInJupiters = gasGiant.massInJupiters || (gasGiant.mass / 50.0);
        const radiusInJupiters = gasGiant.radius / GAS_GIANT_RADIUS;
        const radiusInKm = radiusInJupiters * 69911; // Jupiter radius in km
        const massInKg = massInJupiters * 1.898e27; // Jupiter mass in kg
        
        // Real density calculation (kg/m³)
        const volume = (4/3) * Math.PI * Math.pow(radiusInKm * 1000, 3);
        const density = massInKg / volume;
        
        // Real escape velocity (m/s)
        const G = 6.67430e-11;
        const escapeVelocity = Math.sqrt((2 * G * massInKg) / (radiusInKm * 1000));
        
        // Real surface gravity (m/s²)
        const surfaceGravity = (G * massInKg) / Math.pow(radiusInKm * 1000, 2);
        
        // Real orbital period
        const distanceFromCenter = Math.hypot(gasGiant.pos.x, gasGiant.pos.y);
        const centralMass = 1000; // Assume central mass in simulation units
        const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(distanceFromCenter * 1e9, 3) / (G * centralMass * 1.989e30));
        const orbitalPeriodDays = orbitalPeriod / (24 * 3600);
        
        // Use the actual giant type from the object, or determine from mass
        let giantType = gasGiant.giantType || 'Gas Giant';
        if (!gasGiant.giantType) {
            if (massInJupiters > 13) giantType = 'Brown Dwarf';
            else if (massInJupiters > 5) giantType = 'Super-Jupiter';
            else if (massInJupiters > 1) giantType = 'Jupiter-like';
            else if (massInJupiters > 0.5) giantType = 'Neptune-like';
            else giantType = 'Mini-Neptune';
        }
        
        // Convert giant type to display format
        const displayType = giantType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
        
        return {
            icon: '🪐',
            title: 'Gas Giant',
            stats: [
                { label: 'Mass', value: `${massInJupiters.toFixed(2)} M♃ (${massInKg.toExponential(2)} kg)` },
                { label: 'Radius', value: `${radiusInJupiters.toFixed(2)} R♃ (${radiusInKm.toFixed(0)} km)` },
                { label: 'Density', value: `${density.toFixed(0)} kg/m³` },
                { label: 'Surface Gravity', value: `${surfaceGravity.toFixed(1)} m/s²` },
                { label: 'Escape Velocity', value: `${(escapeVelocity/1000).toFixed(1)} km/s` },
                { label: 'Orbital Period', value: orbitalPeriodDays > 365 ? `${(orbitalPeriodDays/365).toFixed(1)} years` : `${orbitalPeriodDays.toFixed(1)} days` },
                { label: 'Type', value: displayType },
                { label: 'Position', value: `(${gasGiant.pos.x.toFixed(1)}, ${gasGiant.pos.y.toFixed(1)})` },
                { label: 'Velocity', value: `${Math.hypot(gasGiant.vel.x, gasGiant.vel.y).toFixed(1)} units/s` }
            ],
            description: `A ${displayType.toLowerCase()} with ${massInJupiters > 10 ? 'enormous' : massInJupiters > 1 ? 'substantial' : 'moderate'} mass. ${giantType === 'brown_dwarf' ? 'This object is massive enough to fuse deuterium but not hydrogen, making it a failed star.' : giantType === 'super_jupiter' ? 'This massive gas giant has extreme atmospheric pressures and may have formed directly from a protoplanetary disk.' : giantType === 'jupiter_like' ? 'This Jupiter-like planet has a thick hydrogen-helium atmosphere with distinctive banding patterns.' : giantType === 'neptune_like' ? 'This Neptune-like ice giant has a composition rich in water, ammonia, and methane ices.' : 'This mini-Neptune has a substantial atmosphere but is smaller than typical gas giants.'}`
        };
    };

    const getAsteroidInfo = (asteroid) => {
        const massInEarths = asteroid.mass / 1.0;
        const massInKg = massInEarths * 5.972e24;
        const radiusInKm = asteroid.radius * 1000; // Rough conversion
        const radiusInM = radiusInKm * 1000;
        
        // Real density calculation (kg/m³)
        const volume = (4/3) * Math.PI * Math.pow(radiusInM, 3);
        const density = massInKg / volume;
        
        // Real escape velocity (m/s)
        const G = 6.67430e-11;
        const escapeVelocity = Math.sqrt((2 * G * massInKg) / radiusInM);
        
        // Real surface gravity (m/s²)
        const surfaceGravity = (G * massInKg) / Math.pow(radiusInM, 2);
        
        // Real orbital period
        const distanceFromCenter = Math.hypot(asteroid.pos.x, asteroid.pos.y);
        const centralMass = 1000; // Assume central mass in simulation units
        const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(distanceFromCenter * 1e9, 3) / (G * centralMass * 1.989e30));
        const orbitalPeriodDays = orbitalPeriod / (24 * 3600);
        
        let asteroidType = 'Asteroid';
        if (asteroid.radius > 5) asteroidType = 'Dwarf Planet';
        else if (asteroid.radius > 2) asteroidType = 'Large Asteroid';
        else asteroidType = 'Small Asteroid';
        
        return {
            icon: '☄️',
            title: 'Asteroid',
            stats: [
                { label: 'Mass', value: `${massInEarths.toFixed(4)} M⊕ (${massInKg.toExponential(2)} kg)` },
                { label: 'Radius', value: `${radiusInKm.toFixed(0)} km` },
                { label: 'Density', value: `${density.toFixed(0)} kg/m³` },
                { label: 'Surface Gravity', value: `${surfaceGravity.toFixed(3)} m/s²` },
                { label: 'Escape Velocity', value: `${escapeVelocity.toFixed(1)} m/s` },
                { label: 'Orbital Period', value: orbitalPeriodDays > 365 ? `${(orbitalPeriodDays/365).toFixed(1)} years` : `${orbitalPeriodDays.toFixed(1)} days` },
                { label: 'Type', value: asteroidType },
                { label: 'Position', value: `(${asteroid.pos.x.toFixed(1)}, ${asteroid.pos.y.toFixed(1)})` },
                { label: 'Velocity', value: `${Math.hypot(asteroid.vel.x, asteroid.vel.y).toFixed(1)} units/s` }
            ],
            description: `A ${asteroidType.toLowerCase()} with ${asteroid.radius > 5 ? 'significant' : asteroid.radius > 2 ? 'moderate' : 'minimal'} mass. ${asteroidType === 'Dwarf Planet' ? 'This object is large enough to be rounded by its own gravity.' : 'This rocky body orbits in the system, potentially as part of a belt or as a rogue object.'}`
        };
    };

    const getNeutronStarInfo = (neutronStar) => {
        const massInSuns = neutronStar.massInSuns || (neutronStar.mass / SOLAR_MASS_UNIT);
        const radiusInKm = neutronStar.radius * 1000; // Rough conversion to km
        const density = neutronStar.mass / (Math.PI * neutronStar.radius * neutronStar.radius);
        const escapeVelocity = Math.sqrt(2 * SETTINGS.gravitational_constant * neutronStar.mass / neutronStar.radius);
        const schwarzschildRadius = 2 * SETTINGS.gravitational_constant * neutronStar.mass / (3e8 * 3e8); // Simplified
        
        const starType = neutronStar.starType || 'Neutron Star';
        const isPulsar = neutronStar.pulsar || false;
        
        return {
            icon: isPulsar ? '⚡' : '⭐',
            title: starType,
            stats: [
                { label: 'Mass', value: `${massInSuns.toFixed(2)} M☉` },
                { label: 'Radius', value: `${radiusInKm.toFixed(0)} km` },
                { label: 'Density', value: `${density.toFixed(2)} mass/unit²` },
                { label: 'Escape Velocity', value: `${escapeVelocity.toFixed(1)} units/s` },
                { label: 'Schwarzschild Radius', value: `${schwarzschildRadius.toFixed(6)} units` },
                { label: 'Type', value: starType },
                { label: 'Pulsar', value: isPulsar ? 'Yes' : 'No' },
                { label: 'Position', value: `(${neutronStar.pos.x.toFixed(1)}, ${neutronStar.pos.y.toFixed(1)})` },
                { label: 'Velocity', value: `${Math.hypot(neutronStar.vel.x, neutronStar.vel.y).toFixed(1)} units/s` }
            ],
            description: `A ${starType.toLowerCase()} with ${massInSuns > 2.0 ? 'extreme' : 'high'} density. ${isPulsar ? 'This pulsar emits regular beams of radiation as it rotates.' : 'This neutron star is the collapsed core of a massive star.'} ${starType === 'Magnetar' ? 'This magnetar has an extremely strong magnetic field, making it one of the most powerful objects in the universe.' : starType === 'Pulsar' ? 'This pulsar rotates rapidly, emitting beams of radiation that sweep across space.' : 'This neutron star is composed almost entirely of neutrons, making it incredibly dense.'}`
        };
    };

    const getWhiteDwarfInfo = (whiteDwarf) => {
        const massInSuns = whiteDwarf.massInSuns || (whiteDwarf.mass / SOLAR_MASS_UNIT);
        const radiusInEarths = whiteDwarf.radius / PLANET_RADIUS; // Compare to Earth radius
        const density = whiteDwarf.mass / (Math.PI * whiteDwarf.radius * whiteDwarf.radius);
        const escapeVelocity = Math.sqrt(2 * SETTINGS.gravitational_constant * whiteDwarf.mass / whiteDwarf.radius);
        const chandrasekharLimit = 1.4; // Solar masses
        
        const dwarfType = whiteDwarf.dwarfType || 'Carbon-Oxygen';
        
        return {
            icon: '⭐',
            title: 'White Dwarf',
            stats: [
                { label: 'Mass', value: `${massInSuns.toFixed(2)} M☉` },
                { label: 'Radius', value: `${radiusInEarths.toFixed(2)} R⊕` },
                { label: 'Density', value: `${density.toFixed(2)} mass/unit²` },
                { label: 'Escape Velocity', value: `${escapeVelocity.toFixed(1)} units/s` },
                { label: 'Chandrasekhar Limit', value: `${chandrasekharLimit} M☉` },
                { label: 'Type', value: dwarfType },
                { label: 'Position', value: `(${whiteDwarf.pos.x.toFixed(1)}, ${whiteDwarf.pos.y.toFixed(1)})` },
                { label: 'Velocity', value: `${Math.hypot(whiteDwarf.vel.x, whiteDwarf.vel.y).toFixed(1)} units/s` }
            ],
            description: `A ${dwarfType.toLowerCase()} white dwarf with ${massInSuns > 1.2 ? 'high' : massInSuns > 0.6 ? 'moderate' : 'low'} mass. ${dwarfType === 'Oxygen-Neon' ? 'This massive white dwarf is near the Chandrasekhar limit and may become a neutron star.' : dwarfType === 'Carbon-Oxygen' ? 'This is the most common type of white dwarf, composed of carbon and oxygen.' : 'This low-mass white dwarf is composed primarily of helium.'} ${massInSuns > chandrasekharLimit ? 'This white dwarf exceeds the Chandrasekhar limit and may collapse into a neutron star.' : 'This white dwarf is stable and will slowly cool over billions of years.'}`
        };
    };

    const getCometInfo = (comet) => {
        const massInComets = comet.massInComets || (comet.mass / 0.1);
        const radiusInKm = comet.radius * 1000; // Rough conversion to km
        const density = comet.mass / (Math.PI * comet.radius * comet.radius);
        const escapeVelocity = Math.sqrt(2 * SETTINGS.gravitational_constant * comet.mass / comet.radius);
        const tailLength = comet.tailLength || 35;
        
        const cometType = comet.cometType || 'short_period';
        const displayType = cometType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
        
        return {
            icon: '☄️',
            title: 'Comet',
            stats: [
                { label: 'Mass', value: `${massInComets.toFixed(3)} C` },
                { label: 'Radius', value: `${radiusInKm.toFixed(0)} km` },
                { label: 'Density', value: `${density.toFixed(2)} mass/unit²` },
                { label: 'Escape Velocity', value: `${escapeVelocity.toFixed(1)} units/s` },
                { label: 'Tail Length', value: `${tailLength.toFixed(0)} units` },
                { label: 'Type', value: displayType },
                { label: 'Position', value: `(${comet.pos.x.toFixed(1)}, ${comet.pos.y.toFixed(1)})` },
                { label: 'Velocity', value: `${Math.hypot(comet.vel.x, comet.vel.y).toFixed(1)} units/s` }
            ],
            description: `A ${displayType.toLowerCase()} comet with ${massInComets > 0.1 ? 'substantial' : massInComets > 0.01 ? 'moderate' : 'small'} mass. ${cometType === 'periodic' ? 'This periodic comet returns to the inner solar system regularly, like Halley\'s Comet.' : cometType === 'long_period' ? 'This long-period comet has an orbital period of more than 200 years.' : 'This short-period comet completes its orbit in less than 200 years.'} The comet\'s tail is ${tailLength > 50 ? 'very long' : tailLength > 30 ? 'moderate' : 'short'} and points away from the sun due to solar radiation pressure.`
        };
    };

    const showObjectInspector = (object, type) => {
        // Store the current object for auto-updating
        state.selectedObject = { object, type };
        
        const updateInspector = () => {
            if (!state.inspector_open || !state.selectedObject) return;
            
            let info;
            switch (state.selectedObject.type) {
                case 'BlackHole':
                    info = getBlackHoleInfo(state.selectedObject.object);
                    break;
                case 'Star':
                    info = getStarInfo(state.selectedObject.object);
                    break;
                case 'NeutronStar':
                    info = getNeutronStarInfo(state.selectedObject.object);
                    break;
                case 'WhiteDwarf':
                    info = getWhiteDwarfInfo(state.selectedObject.object);
                    break;
                case 'Planet':
                    info = getPlanetInfo(state.selectedObject.object);
                    break;
                case 'GasGiant':
                    info = getGasGiantInfo(state.selectedObject.object);
                    break;
                case 'Comet':
                    info = getCometInfo(state.selectedObject.object);
                    break;
                case 'Asteroid':
                    info = getAsteroidInfo(state.selectedObject.object);
                    break;
                default:
                    return;
            }
            
            inspectorTitle.innerHTML = `<span class="object-icon">${info.icon}</span>${info.title}`;
            
            let content = '';
            info.stats.forEach(stat => {
                content += `
                    <div class="stat-row">
                        <span class="stat-label">${stat.label}:</span>
                        <span class="stat-value">${stat.value}</span>
                    </div>
                `;
            });
            
            content += `<div class="object-description">${info.description}</div>`;
            inspectorContent.innerHTML = content;
        };
        
        // Initial update
        updateInspector();
        
        // Set up auto-update interval
        if (state.inspectorUpdateInterval) {
            clearInterval(state.inspectorUpdateInterval);
        }
        state.inspectorUpdateInterval = setInterval(updateInspector, 100); // Update 10 times per second
        
        objectInspector.classList.add('visible');
        state.inspector_open = true;
    };

    const hideObjectInspector = () => {
        objectInspector.classList.remove('visible');
        state.inspector_open = false;
        
        // Clear auto-update interval
        if (state.inspectorUpdateInterval) {
            clearInterval(state.inspectorUpdateInterval);
            state.inspectorUpdateInterval = null;
        }
        state.selectedObject = null;
    };

    class PhysicsObject {
        constructor(pos, vel, mass, radius, obj_type = "object") {
            this.id = PhysicsObject_id_counter++;
            this.pos = { ...pos };
            this.vel = { ...vel };
            this.mass = parseFloat(mass);
            this.radius = parseFloat(radius);
            this.obj_type = obj_type;
            this.trail = [];
            this.alive = true;
        }

        update_physics(dt, gravity_sources) {
            if (!this.alive) return;
            const { ax, ay } = gravitational_acceleration(this.pos, gravity_sources);
            this.vel.x += ax * dt;
            this.vel.y += ay * dt;
            this.pos.x += this.vel.x * dt;
            this.pos.y += this.vel.y * dt;
        }

        update_trail() {
            if (!this.alive) return;
            // Add position with timestamp and velocity for better trail effects
            this.trail.push({ 
                ...this.pos, 
                timestamp: Date.now(),
                velocity: Math.hypot(this.vel.x, this.vel.y),
                age: 0
            });
            if (this.trail.length > SETTINGS.trail_length) this.trail.shift();
            
            // Update age of all trail points
            this.trail.forEach(point => point.age += 1);
        }

        check_absorption(bh_list) {
            if (!this.alive) return false;
            for (const bh of bh_list) {
                const dx = this.pos.x - bh.pos.x;
                const dy = this.pos.y - bh.pos.y;
                if (dx*dx + dy*dy < (bh.radius + ABSORB_BUFFER)**2) {
                    this.alive = false;
                    bh.mass += this.mass || 0;
                    bh.updateRadius();
                    return true;
                }
            }
            return false;
        }

        get_state() { return { id: this.id, type: this.obj_type, pos: this.pos, vel: this.vel, mass: this.mass, radius: this.radius, alive: this.alive }; }
        set_state(s) { Object.assign(this, s); this.trail = []; }
        draw(ctx) {}
    }

    class Planet extends PhysicsObject {
        constructor(pos, vel, massInEarths = null) {
            let finalMassInEarths;
            if (massInEarths !== null) {
                finalMassInEarths = massInEarths;
            } else {
                // Skewed distribution to favor smaller, more common planets. Range ~0.1 to 5 Earth masses.
                finalMassInEarths = Math.pow(10, (Math.random() * 1.2) - 1.0); 
            }
            
            const radius = PLANET_RADIUS * Math.pow(finalMassInEarths, 0.3); // Mass-radius relation for planets
            const mass = finalMassInEarths; // 1.0 = 1 Earth mass
            
            super(pos, vel, mass, radius, "Planet");
            this.massInEarths = finalMassInEarths;
            this.density = this.calculateDensity();
            this.intact = true;
        }
        
        calculateDensity() {
            // Determine planet type based on mass and random factors
            if (this.massInEarths > 3.0) {
                // Gas giant or ice giant
                return Math.random() > 0.5 ? 'gaseous' : 'icy';
            } else if (this.massInEarths > 0.5) {
                // Rocky planet (terrestrial or super-earth)
                return 'rocky';
            } else {
                // Dwarf planet or asteroid-like
                return 'rocky';
            }
        }
        
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            
            // Base color based on density
            let baseColor;
            switch (this.density) {
                case 'gaseous':
                    baseColor = '#87CEEB'; // Light blue for gas giants
                    break;
                case 'icy':
                    baseColor = '#E6E6FA'; // Lavender for ice giants
                    break;
                case 'rocky':
                default:
                    baseColor = SETTINGS.planet_base_color;
                    break;
            }
            
            ctx.fillStyle = compute_dynamic_color(baseColor, this.pos, bh_list);
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Add atmospheric bands for gas giants
            if (this.density === 'gaseous' && this.radius * state.zoom > 3) {
                ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
                const band_height = Math.max(1 / state.zoom, this.radius * 0.2);
                ctx.fillRect(world_pos.x - this.radius, world_pos.y - this.radius / 2 - band_height / 2, this.radius * 2, band_height);
                ctx.fillRect(world_pos.x - this.radius, world_pos.y + this.radius / 2 - band_height / 2, this.radius * 2, band_height);
            }
            
            // Add ice caps for icy planets
            if (this.density === 'icy' && this.radius * state.zoom > 3) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                const cap_height = Math.max(1 / state.zoom, this.radius * 0.15);
                ctx.fillRect(world_pos.x - this.radius, world_pos.y - this.radius - cap_height, this.radius * 2, cap_height);
                ctx.fillRect(world_pos.x - this.radius, world_pos.y + this.radius, this.radius * 2, cap_height);
            }
            
            // Draw mass label for larger planets
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            const true_screen_pos = {
                x: world_pos.x * state.zoom + canvas.width / 2 + state.pan.x,
                y: -world_pos.y * state.zoom + canvas.height / 2 + state.pan.y
            };
            const screen_radius = this.radius * state.zoom;
            
            if (screen_radius > 4) { // Only draw label if planet is big enough on screen
                const label_y_offset = screen_radius + 10;
                ctx.font = '10px Roboto Mono';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 3;
                ctx.fillText(`${this.massInEarths.toFixed(2)} M⊕`, true_screen_pos.x, true_screen_pos.y + label_y_offset);
            }
            ctx.restore();
        }
        
        tidal_mass_loss(bh_list, dt) {
            if (!this.intact || !bh_list || bh_list.length === 0) return { debris_count: 0, fraction: 0 };
            let min_dist_sq = Infinity, closest_bh = null;
            for (const bh of bh_list) {
                const dx = this.pos.x - bh.pos.x;
                const dy = this.pos.y - bh.pos.y;
                const dist_sq = dx*dx + dy*dy;
                if (dist_sq < min_dist_sq) {
                    min_dist_sq = dist_sq;
                    closest_bh = bh;
                }
            }
            if (!closest_bh) return { debris_count: 0, fraction: 0 };
            
            // Planets have a smaller tidal disruption radius than stars
            const tidal_threshold_sq = (closest_bh.radius * 3)**2;
            if (min_dist_sq < tidal_threshold_sq) {
                const min_dist = Math.sqrt(min_dist_sq);
                const tidal_threshold = Math.sqrt(tidal_threshold_sq);
                const fraction = Math.max(0.0, (tidal_threshold - min_dist) / tidal_threshold);
                
                // Planets lose mass more slowly than stars
                this.mass -= this.mass * fraction * 0.05 * dt;
                let debris_count = Math.floor(fraction * 20 * dt);
                
                if (this.mass <= 0.1) {
                    this.intact = false;
                    this.alive = false;
                    debris_count += 15;
                }
                return { debris_count, fraction };
            }
            return { debris_count: 0, fraction: 0 };
        }
        
        get_state() { 
            const baseState = super.get_state();
            return { ...baseState, massInEarths: this.massInEarths, density: this.density };
        }
        set_state(s) {
            super.set_state(s);
            this.massInEarths = s.massInEarths;
            this.density = s.density;
        }
    }
    
    class GasGiant extends PhysicsObject {
        constructor(pos, vel, massInJupiters = null) {
            let finalMassInJupiters;
            if (massInJupiters !== null) {
                finalMassInJupiters = massInJupiters;
            } else {
                // Skewed distribution to favor smaller gas giants. Range ~0.3 to 15 Jupiter masses.
                finalMassInJupiters = Math.pow(10, (Math.random() * 1.8) - 0.5); 
            }
            
            const radius = GAS_GIANT_RADIUS * Math.pow(finalMassInJupiters, 0.3); // Reduced scaling from 0.4 to 0.3
            const mass = finalMassInJupiters * 50.0; // 50.0 = 1 Jupiter mass
            
            super(pos, vel, mass, radius, "GasGiant");
            this.massInJupiters = finalMassInJupiters;
            this.giantType = this.calculateGiantType();
            this.intact = true;
        }
        
        calculateGiantType() {
            // Determine gas giant type based on mass
            if (this.massInJupiters > 13) {
                return 'brown_dwarf'; // Brown dwarf - massive enough to fuse deuterium
            } else if (this.massInJupiters > 5) {
                return 'super_jupiter'; // Super-Jupiter
            } else if (this.massInJupiters > 1) {
                return 'jupiter_like'; // Jupiter-like
            } else if (this.massInJupiters > 0.5) {
                return 'neptune_like'; // Neptune-like
            } else {
                return 'mini_neptune'; // Mini-Neptune
            }
        }
        
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            
            // Base color based on giant type
            let baseColor;
            switch (this.giantType) {
                case 'brown_dwarf':
                    baseColor = '#8B4513'; // Brown for brown dwarfs
                    break;
                case 'super_jupiter':
                    baseColor = '#DAA520'; // Golden for super-Jupiters
                    break;
                case 'jupiter_like':
                    baseColor = '#D2B48C'; // Tan for Jupiter-like
                    break;
                case 'neptune_like':
                    baseColor = '#4169E1'; // Blue for Neptune-like
                    break;
                case 'mini_neptune':
                default:
                    baseColor = '#87CEEB'; // Light blue for mini-Neptunes
                    break;
            }
            
            ctx.fillStyle = compute_dynamic_color(baseColor, this.pos, bh_list);
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Add realistic atmospheric features for larger gas giants
            if (this.radius * state.zoom > 4) {
                let bandColor, highlightColor;
                switch (this.giantType) {
                    case 'brown_dwarf':
                        bandColor = 'rgba(139, 69, 19, 0.6)';
                        highlightColor = 'rgba(160, 82, 45, 0.4)';
                        break;
                    case 'super_jupiter':
                        bandColor = 'rgba(218, 165, 32, 0.5)';
                        highlightColor = 'rgba(255, 215, 0, 0.3)';
                        break;
                    case 'jupiter_like':
                        bandColor = 'rgba(160, 82, 45, 0.5)';
                        highlightColor = 'rgba(210, 180, 140, 0.3)';
                        break;
                    case 'neptune_like':
                        bandColor = 'rgba(65, 105, 225, 0.5)';
                        highlightColor = 'rgba(100, 149, 237, 0.3)';
                        break;
                    case 'mini_neptune':
                    default:
                        bandColor = 'rgba(135, 206, 235, 0.5)';
                        highlightColor = 'rgba(173, 216, 230, 0.3)';
                        break;
                }
                
                // Draw atmospheric bands as curved shapes instead of rectangles
                const numBands = this.massInJupiters > 3 ? 4 : 2;
                for (let i = 0; i < numBands; i++) {
                    const bandOffset = (i - (numBands-1)/2) * (this.radius * 0.4);
                    const bandWidth = this.radius * 0.15;
                    
                    // Create curved band shape
                    ctx.fillStyle = bandColor;
                    ctx.beginPath();
                    ctx.ellipse(world_pos.x, world_pos.y + bandOffset, this.radius * 0.9, bandWidth, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Add highlight on top of band
                    ctx.fillStyle = highlightColor;
                    ctx.beginPath();
                    ctx.ellipse(world_pos.x, world_pos.y + bandOffset - bandWidth * 0.3, this.radius * 0.85, bandWidth * 0.4, 0, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Add polar regions for larger giants
                if (this.massInJupiters > 2) {
                    ctx.fillStyle = bandColor;
                    ctx.beginPath();
                    ctx.ellipse(world_pos.x, world_pos.y - this.radius * 0.7, this.radius * 0.3, this.radius * 0.2, 0, 0, 2 * Math.PI);
                    ctx.ellipse(world_pos.x, world_pos.y + this.radius * 0.7, this.radius * 0.3, this.radius * 0.2, 0, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // Draw mass label for larger gas giants
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            const true_screen_pos = {
                x: world_pos.x * state.zoom + canvas.width / 2 + state.pan.x,
                y: -world_pos.y * state.zoom + canvas.height / 2 + state.pan.y
            };
            const screen_radius = this.radius * state.zoom;
            
            if (screen_radius > 6) { // Only draw label if gas giant is big enough on screen
                const label_y_offset = screen_radius + 12;
                ctx.font = '11px Roboto Mono';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 3;
                ctx.fillText(`${this.massInJupiters.toFixed(2)} M♃`, true_screen_pos.x, true_screen_pos.y + label_y_offset);
            }
            ctx.restore();
        }
        
        tidal_mass_loss(bh_list, dt) {
            if (!this.intact || !bh_list || bh_list.length === 0) return { debris_count: 0, fraction: 0 };
            let min_dist_sq = Infinity, closest_bh = null;
            for (const bh of bh_list) {
                const dx = this.pos.x - bh.pos.x;
                const dy = this.pos.y - bh.pos.y;
                const dist_sq = dx*dx + dy*dy;
                if (dist_sq < min_dist_sq) {
                    min_dist_sq = dist_sq;
                    closest_bh = bh;
                }
            }
            if (!closest_bh) return { debris_count: 0, fraction: 0 };
            
            // Gas giants have a larger tidal disruption radius than planets but smaller than stars
            const tidal_threshold_sq = (closest_bh.radius * 4)**2;
            if (min_dist_sq < tidal_threshold_sq) {
                const min_dist = Math.sqrt(min_dist_sq);
                const tidal_threshold = Math.sqrt(tidal_threshold_sq);
                const fraction = Math.max(0.0, (tidal_threshold - min_dist) / tidal_threshold);
                
                // Gas giants lose mass more slowly than stars but faster than planets
                this.mass -= this.mass * fraction * 0.08 * dt;
                let debris_count = Math.floor(fraction * 35 * dt);
                
                if (this.mass <= 0.5) {
                    this.intact = false;
                    this.alive = false;
                    debris_count += 20;
                }
                return { debris_count, fraction };
            }
            return { debris_count: 0, fraction: 0 };
        }
        
        get_state() { 
            const baseState = super.get_state();
            return { ...baseState, massInJupiters: this.massInJupiters, giantType: this.giantType };
        }
        set_state(s) {
            super.set_state(s);
            this.massInJupiters = s.massInJupiters;
            this.giantType = s.giantType;
        }
    }
    
    class Asteroid extends PhysicsObject {
        constructor(pos, vel) { super(pos, vel, 0.1, ASTEROID_RADIUS, "Asteroid"); }
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    class NeutronStar extends PhysicsObject {
        constructor(pos, vel, massInSuns = null) {
            let finalMassInSuns;
            if (massInSuns !== null) {
                finalMassInSuns = massInSuns;
            } else {
                // Neutron stars have a narrow mass range. Range ~1.1 to 2.5 solar masses
                finalMassInSuns = 1.1 + Math.random() * 1.4; 
            }
            
            // Neutron stars are extremely dense - radius is nearly constant
            const radius = STAR_OBJ_RADIUS * 0.05; // Very small, nearly constant size
            const mass = finalMassInSuns * SOLAR_MASS_UNIT;
            
            super(pos, vel, mass, radius, "NeutronStar");
            this.massInSuns = finalMassInSuns;
            this.starType = this.calculateStarType();
            this.pulsar = Math.random() > 0.7; // 30% chance to be a pulsar
            this.intact = true;
        }
        
        // Override updateRadius to prevent errors - neutron stars have nearly constant radius
        updateRadius() {
            // Neutron stars maintain nearly constant radius regardless of mass
            this.radius = STAR_OBJ_RADIUS * 0.05;
        }
        
        calculateStarType() {
            // Determine neutron star type based on mass and random factors
            if (this.massInSuns > 2.0) {
                return 'Magnetar'; // Very massive neutron stars with strong magnetic fields
            } else if (this.pulsar) {
                return 'Pulsar'; // Rotating neutron star with beams
            } else {
                return 'Neutron Star'; // Standard neutron star
            }
        }
        
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            const true_screen_pos = world_to_screen(this.pos);
            const screen_radius = this.radius * state.zoom;
            
            ctx.save();
            
            // Draw neutron star core (very small, bright)
            const gradient = ctx.createRadialGradient(true_screen_pos.x, true_screen_pos.y, 0, true_screen_pos.x, true_screen_pos.y, screen_radius * 3);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.3, '#00ffff');
            gradient.addColorStop(0.7, '#0080ff');
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(true_screen_pos.x, true_screen_pos.y, screen_radius * 3, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw central core
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(true_screen_pos.x, true_screen_pos.y, screen_radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Add pulsar beams if applicable
            if (this.pulsar && screen_radius > 2) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2 / state.zoom;
                ctx.setLineDash([3, 3]);
                
                // Draw rotating beams
                const time = Date.now() * 0.001;
                const beamAngle = time * 2; // Rotating beams
                
                for (let i = 0; i < 2; i++) {
                    const angle = beamAngle + (i * Math.PI);
                    const beamLength = screen_radius * 8;
                    const endX = true_screen_pos.x + Math.cos(angle) * beamLength;
                    const endY = true_screen_pos.y + Math.sin(angle) * beamLength;
                    
                    ctx.beginPath();
                    ctx.moveTo(true_screen_pos.x, true_screen_pos.y);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
            }
            
            // Draw label if large enough
            if (screen_radius > 4) {
                const label_y_offset = screen_radius + 12;
                ctx.font = '11px Roboto Mono';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 2;
                const label = this.pulsar ? `${this.massInSuns.toFixed(2)} M☉ ⚡` : `${this.massInSuns.toFixed(2)} M☉`;
                ctx.fillText(label, true_screen_pos.x, true_screen_pos.y + label_y_offset);
            }
            ctx.restore();
        }
        
        tidal_mass_loss(bh_list, dt) {
            if (!this.intact || !bh_list || bh_list.length === 0) return { debris_count: 0, fraction: 0 };
            let min_dist_sq = Infinity, closest_bh = null;
            for (const bh of bh_list) {
                const dx = this.pos.x - bh.pos.x;
                const dy = this.pos.y - bh.pos.y;
                const dist_sq = dx*dx + dy*dy;
                if (dist_sq < min_dist_sq) {
                    min_dist_sq = dist_sq;
                    closest_bh = bh;
                }
            }
            if (!closest_bh) return { debris_count: 0, fraction: 0 };
            
            // Neutron stars are extremely dense and very hard to disrupt
            const tidal_threshold_sq = (closest_bh.radius * 8)**2;
            if (min_dist_sq < tidal_threshold_sq) {
                const min_dist = Math.sqrt(min_dist_sq);
                const tidal_threshold = Math.sqrt(tidal_threshold_sq);
                const fraction = Math.max(0.0, (tidal_threshold - min_dist) / tidal_threshold);
                
                this.mass -= this.mass * fraction * 0.01 * dt; // Extremely slow mass loss
                let debris_count = Math.floor(fraction * 5 * dt);
                
                if (this.mass <= 0.1) {
                    this.intact = false;
                    this.alive = false;
                    debris_count += 50;
                }
                return { debris_count, fraction };
            }
            return { debris_count: 0, fraction: 0 };
        }
        
        get_state() { 
            const baseState = super.get_state();
            return { ...baseState, massInSuns: this.massInSuns, starType: this.starType, pulsar: this.pulsar };
        }
        set_state(s) {
            super.set_state(s);
            this.massInSuns = s.massInSuns;
            this.starType = s.starType;
            this.pulsar = s.pulsar;
        }
    }

    class WhiteDwarf extends PhysicsObject {
        constructor(pos, vel, massInSuns = null) {
            let finalMassInSuns;
            if (massInSuns !== null) {
                finalMassInSuns = massInSuns;
            } else {
                // White dwarfs have a mass range. Range ~0.1 to 1.4 solar masses (Chandrasekhar limit)
                finalMassInSuns = 0.1 + Math.random() * 1.3; 
            }
            
            // White dwarfs are very dense but larger than neutron stars
            const radius = STAR_OBJ_RADIUS * 0.1; // Small but larger than neutron stars
            const mass = finalMassInSuns * SOLAR_MASS_UNIT;
            
            super(pos, vel, mass, radius, "WhiteDwarf");
            this.massInSuns = finalMassInSuns;
            this.dwarfType = this.calculateDwarfType();
            this.intact = true;
        }
        
        // Override updateRadius to prevent errors - white dwarfs have nearly constant radius
        updateRadius() {
            // White dwarfs maintain nearly constant radius regardless of mass
            this.radius = STAR_OBJ_RADIUS * 0.1;
        }
        
        calculateDwarfType() {
            // Determine white dwarf type based on mass
            if (this.massInSuns > 1.2) {
                return 'Oxygen-Neon'; // Very massive white dwarfs
            } else if (this.massInSuns > 0.6) {
                return 'Carbon-Oxygen'; // Most common type
            } else {
                return 'Helium'; // Low mass white dwarfs
            }
        }
        
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            const true_screen_pos = world_to_screen(this.pos);
            const screen_radius = this.radius * state.zoom;
            
            ctx.save();
            
            // Draw white dwarf (small, bright, bluish-white)
            const gradient = ctx.createRadialGradient(true_screen_pos.x, true_screen_pos.y, 0, true_screen_pos.x, true_screen_pos.y, screen_radius * 2);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.4, '#e6f3ff');
            gradient.addColorStop(0.8, '#b3d9ff');
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(true_screen_pos.x, true_screen_pos.y, screen_radius * 2, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw central core
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(true_screen_pos.x, true_screen_pos.y, screen_radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw label if large enough
            if (screen_radius > 6) {
                const label_y_offset = screen_radius + 12;
                ctx.font = '11px Roboto Mono';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 3;
                ctx.fillText(`${this.massInSuns.toFixed(2)} M☉`, true_screen_pos.x, true_screen_pos.y + label_y_offset);
            }
            ctx.restore();
        }
        
        tidal_mass_loss(bh_list, dt) {
            if (!this.intact || !bh_list || bh_list.length === 0) return { debris_count: 0, fraction: 0 };
            let min_dist_sq = Infinity, closest_bh = null;
            for (const bh of bh_list) {
                const dx = this.pos.x - bh.pos.x;
                const dy = this.pos.y - bh.pos.y;
                const dist_sq = dx*dx + dy*dy;
                if (dist_sq < min_dist_sq) {
                    min_dist_sq = dist_sq;
                    closest_bh = bh;
                }
            }
            if (!closest_bh) return { debris_count: 0, fraction: 0 };
            
            // White dwarfs are very dense and hard to disrupt
            const tidal_threshold_sq = (closest_bh.radius * 5)**2;
            if (min_dist_sq < tidal_threshold_sq) {
                const min_dist = Math.sqrt(min_dist_sq);
                const tidal_threshold = Math.sqrt(tidal_threshold_sq);
                const fraction = Math.max(0.0, (tidal_threshold - min_dist) / tidal_threshold);
                
                this.mass -= this.mass * fraction * 0.02 * dt; // Very slow mass loss
                let debris_count = Math.floor(fraction * 10 * dt);
                
                if (this.mass <= 0.1) {
                    this.intact = false;
                    this.alive = false;
                    debris_count += 30;
                }
                return { debris_count, fraction };
            }
            return { debris_count: 0, fraction: 0 };
        }
        
        get_state() { 
            const baseState = super.get_state();
            return { ...baseState, massInSuns: this.massInSuns, dwarfType: this.dwarfType };
        }
        set_state(s) {
            super.set_state(s);
            this.massInSuns = s.massInSuns;
            this.dwarfType = s.dwarfType;
        }
    }

    class Comet extends PhysicsObject {
        constructor(pos, vel, massInComets = null) {
            let finalMassInComets;
            if (massInComets !== null) {
                finalMassInComets = massInComets;
            } else {
                // Comets are typically very small. Range ~0.001 to 0.1 comet masses (Halley's Comet = 1.0)
                finalMassInComets = Math.pow(10, (Math.random() * 2) - 3); 
            }
            
            const radius = ASTEROID_RADIUS * Math.pow(finalMassInComets, 0.4) * 0.8; // Comets are smaller than asteroids
            const mass = finalMassInComets * 0.1; // 0.1 = typical comet mass
            
            super(pos, vel, mass, radius, "Comet");
            this.massInComets = finalMassInComets;
            this.cometType = this.calculateCometType();
            this.tailLength = Math.random() * 50 + 20; // Random tail length
            this.intact = true;
        }
        
        calculateCometType() {
            // Determine comet type based on mass and random factors
            if (this.massInComets > 0.1) {
                return 'periodic'; // Large periodic comets like Halley's
            } else if (this.massInComets > 0.01) {
                return 'long_period'; // Long-period comets
            } else {
                return 'short_period'; // Short-period comets
            }
        }
        
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            const true_screen_pos = world_to_screen(this.pos);
            const screen_radius = this.radius * state.zoom;
            
            ctx.save();
            
            // Draw comet tail (opposite to velocity direction)
            if (screen_radius > 1) {
                const speed = Math.hypot(this.vel.x, this.vel.y);
                if (speed > 0.1) {
                    const tailDirection = { x: -this.vel.x / speed, y: -this.vel.y / speed };
                    const tailLength = Math.min(this.tailLength * state.zoom, 100);
                    
                    // Draw tail gradient
                    const gradient = ctx.createLinearGradient(
                        true_screen_pos.x, true_screen_pos.y,
                        true_screen_pos.x + tailDirection.x * tailLength,
                        true_screen_pos.y + tailDirection.y * tailLength
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.3, 'rgba(200, 255, 255, 0.6)');
                    gradient.addColorStop(0.7, 'rgba(150, 200, 255, 0.3)');
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(true_screen_pos.x, true_screen_pos.y, screen_radius * 2, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // Draw comet nucleus
            ctx.fillStyle = '#f0f0f0';
            ctx.beginPath();
            ctx.arc(true_screen_pos.x, true_screen_pos.y, screen_radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw label if large enough
            if (screen_radius > 3) {
                const label_y_offset = screen_radius + 12;
                ctx.font = '10px Roboto Mono';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 2;
                ctx.fillText(`${this.massInComets.toFixed(3)} C`, true_screen_pos.x, true_screen_pos.y + label_y_offset);
            }
            ctx.restore();
        }
        
        tidal_mass_loss(bh_list, dt) {
            if (!this.intact || !bh_list || bh_list.length === 0) return { debris_count: 0, fraction: 0 };
            let min_dist_sq = Infinity, closest_bh = null;
            for (const bh of bh_list) {
                const dx = this.pos.x - bh.pos.x;
                const dy = this.pos.y - bh.pos.y;
                const dist_sq = dx*dx + dy*dy;
                if (dist_sq < min_dist_sq) {
                    min_dist_sq = dist_sq;
                    closest_bh = bh;
                }
            }
            if (!closest_bh) return { debris_count: 0, fraction: 0 };
            
            // Comets are easily disrupted
            const tidal_threshold_sq = (closest_bh.radius * 2)**2;
            if (min_dist_sq < tidal_threshold_sq) {
                const min_dist = Math.sqrt(min_dist_sq);
                const tidal_threshold = Math.sqrt(tidal_threshold_sq);
                const fraction = Math.max(0.0, (tidal_threshold - min_dist) / tidal_threshold);
                
                this.mass -= this.mass * fraction * 0.1 * dt;
                let debris_count = Math.floor(fraction * 25 * dt);
                
                if (this.mass <= 0.01) {
                    this.intact = false;
                    this.alive = false;
                    debris_count += 20;
                }
                return { debris_count, fraction };
            }
            return { debris_count: 0, fraction: 0 };
        }
        
        get_state() { 
            const baseState = super.get_state();
            return { ...baseState, massInComets: this.massInComets, cometType: this.cometType, tailLength: this.tailLength };
        }
        set_state(s) {
            super.set_state(s);
            this.massInComets = s.massInComets;
            this.cometType = s.cometType;
            this.tailLength = s.tailLength;
        }
    }

    const getStarColor = (massInSuns) => {
        const lowMassColor = { r: 255, g: 180, b: 100 }; // Reddish-Orange for ~0.2 Msun
        const sunColor = { r: 255, g: 255, b: 240 };     // Creamy White for 1.0 Msun
        const highMassColor = { r: 170, g: 200, b: 255 };// Bluish-White for ~3.0+ Msun

        const lerp = (a, b, t) => a + (b - a) * Math.max(0, Math.min(1, t));

        let r, g, b;
        if (massInSuns <= 1.0) {
            const t = (massInSuns - 0.2) / (1.0 - 0.2);
            r = lerp(lowMassColor.r, sunColor.r, t);
            g = lerp(lowMassColor.g, sunColor.g, t);
            b = lerp(lowMassColor.b, sunColor.b, t);
        } else {
            const t = (massInSuns - 1.0) / (3.0 - 1.0);
            r = lerp(sunColor.r, highMassColor.r, t);
            g = lerp(sunColor.g, highMassColor.g, t);
            b = lerp(sunColor.b, highMassColor.b, t);
        }
        return `#${Math.round(r).toString(16).padStart(2, '0')}${Math.round(g).toString(16).padStart(2, '0')}${Math.round(b).toString(16).padStart(2, '0')}`;
    };

    class StarObject extends PhysicsObject {
        constructor(pos, vel, massInSuns = null) {
            let finalMassInSuns;
            if (massInSuns !== null) {
                finalMassInSuns = massInSuns;
            } else {
                // Skewed distribution to favor smaller, more common stars. Range ~0.2 to 3.2 Msun.
                finalMassInSuns = Math.pow(10, (Math.random() * 1.5) - 0.7); 
            }
            
            const radius = STAR_OBJ_RADIUS * Math.pow(finalMassInSuns, 0.85); // Increased scaling from 0.75 to 0.85
            
            super(pos, vel, finalMassInSuns * SOLAR_MASS_UNIT, radius, "StarObject");
            this.massInSuns = finalMassInSuns;
            this.baseColor = getStarColor(this.massInSuns);
            this.intact = true;
        }
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            const starColor = this.baseColor || SETTINGS.star_base_color || '#ffff00';
            ctx.fillStyle = compute_dynamic_color(starColor, this.pos, bh_list, 400.0, {r:255, g:50, b:0});
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();

            // Draw mass label, adapted from BlackHole.draw
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            const true_screen_pos = {
                x: world_pos.x * state.zoom + canvas.width / 2 + state.pan.x,
                y: -world_pos.y * state.zoom + canvas.height / 2 + state.pan.y
            };
            const screen_radius = this.radius * state.zoom;
            
            if (screen_radius > 5) { // Only draw label if star is big enough on screen
                const label_y_offset = screen_radius + 12;
                ctx.font = '12px Roboto Mono';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 4;
                ctx.fillText(`${this.massInSuns.toFixed(2)} Msun`, true_screen_pos.x, true_screen_pos.y + label_y_offset);
            }
            ctx.restore();
        }
        tidal_mass_loss(bh_list, dt) {
            if (!this.intact || !bh_list || bh_list.length === 0) return { debris_count: 0, fraction: 0 };
            let min_dist_sq = Infinity, closest_bh = null;
            for (const bh of bh_list) {
                const dx = this.pos.x - bh.pos.x;
                const dy = this.pos.y - bh.pos.y;
                const dist_sq = dx*dx + dy*dy;
                if (dist_sq < min_dist_sq) {
                    min_dist_sq = dist_sq;
                    closest_bh = bh;
                }
            }
            if (!closest_bh) return { debris_count: 0, fraction: 0 };
            const tidal_threshold_sq = (closest_bh.radius * 5)**2;
            if (min_dist_sq < tidal_threshold_sq) {
                const min_dist = Math.sqrt(min_dist_sq);
                const tidal_threshold = Math.sqrt(tidal_threshold_sq);
                const fraction = Math.max(0.0, (tidal_threshold - min_dist) / tidal_threshold);
                this.mass -= this.mass * fraction * 0.1 * dt;
                let debris_count = Math.floor(fraction * 50 * dt);
                if (this.mass <= 1.0) {
                    this.intact = false;
                    this.alive = false;
                    debris_count += 30;
                }
                return { debris_count, fraction };
            }
            return { debris_count: 0, fraction: 0 };
        }
        get_state() { 
            const baseState = super.get_state();
            return { ...baseState, massInSuns: this.massInSuns, baseColor: this.baseColor };
        }
        set_state(s) {
            super.set_state(s);
            this.massInSuns = s.massInSuns;
            this.baseColor = s.baseColor;
        }
    }
    
    class Debris extends PhysicsObject {
        constructor(pos, vel) { super(pos, vel, 0.01, DEBRIS_RADIUS, "Debris"); }
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            ctx.fillStyle = compute_dynamic_color('#c8c8c8', this.pos, bh_list, 200.0, {r:255, g:100, b:0});
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    class BlackHole {
        constructor(pos, mass, vel = {x: 0, y: 0}) {
            this.pos = { ...pos };
            this.mass = parseFloat(mass);
            this.vel = { ...vel };
            this.obj_type = "BlackHole";
            this.updateRadius();
            
            // Dynamic effects properties
            this.accretion_intensity = 0.0; // 0.0 to 1.0, controls disk brightness
            this.jet_intensity = 0.0; // 0.0 to 1.0, controls jet brightness
            this.disk_growth = 0.0; // 0.0 to 1.0, controls disk size expansion
            this.last_mass = this.mass;
            this.time_since_last_accretion = 0.0;
            this.accretion_decay_rate = 0.2; // Much slower decay for longer-lasting effects
            this.jet_decay_rate = 0.15; // Slower jet decay
            this.disk_growth_decay_rate = 0.1; // Very slow disk growth decay
            this.max_disk_growth = 0.8; // Maximum disk size multiplier
        }

        updateRadius() {
            const mass_scale = Math.max(0.1, this.mass / (DEFAULT_SETTINGS.bh_mass * SOLAR_MASS_UNIT));
            this.radius = BH_RADIUS_BASE * Math.pow(mass_scale, 0.5);
        }
        
        update_orbit(dt, other_bhs) {
            if (SETTINGS.bh_behavior !== "Orbiting" || other_bhs.length <= 1) return;
            const { ax, ay } = gravitational_acceleration(this.pos, other_bhs.filter(bh => bh !== this));
            this.vel.x += ax * dt; this.vel.y += ay * dt;
            const decay_factor = 1.0 - (SETTINGS.orbit_decay_rate * dt);
            this.vel.x *= decay_factor; this.vel.y *= decay_factor;
            this.pos.x += this.vel.x * dt; this.pos.y += this.vel.y * dt;
        }
        
        update_dynamic_effects(dt) {
            // Check if mass increased (something fell in)
            if (this.mass > this.last_mass) {
                const mass_gain = this.mass - this.last_mass;
                const mass_ratio = mass_gain / this.mass;
                
                // Trigger accretion effects based on mass gained
                this.accretion_intensity = Math.min(1.0, this.accretion_intensity + mass_ratio * 15);
                this.jet_intensity = Math.min(1.0, this.jet_intensity + mass_ratio * 8);
                this.disk_growth = Math.min(this.max_disk_growth, this.disk_growth + mass_ratio * 12);
                this.time_since_last_accretion = 0.0;
            }
            
            // Update time and decay effects
            this.time_since_last_accretion += dt;
            
            // Decay accretion intensity (much slower)
            this.accretion_intensity = Math.max(0.0, this.accretion_intensity - this.accretion_decay_rate * dt);
            
            // Decay jet intensity (slower than before)
            this.jet_intensity = Math.max(0.0, this.jet_intensity - this.jet_decay_rate * dt);
            
            // Decay disk growth (very slow)
            this.disk_growth = Math.max(0.0, this.disk_growth - this.disk_growth_decay_rate * dt);
            
            this.last_mass = this.mass;
        }

        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            const world_radius = this.radius;

            if (SETTINGS.show_accretion_disk) {
                // Dynamic disk radius that grows when mass falls in
                const base_disk_radius = world_radius * 2.5;
                const growth_factor = 1.0 + this.disk_growth * 0.6; // Up to 60% larger
                const disk_radius = base_disk_radius * growth_factor;
                
                if (disk_radius > world_radius) {
                    // Dynamic accretion disk with multiple layers
                    const base_intensity = 0.3 + this.accretion_intensity * 0.7;
                    
                    // Inner hot region (closer to event horizon) - also grows
                    const inner_radius = world_radius * (1.2 + this.disk_growth * 0.3);
                    const inner_grad = ctx.createRadialGradient(world_pos.x, world_pos.y, world_radius * 1.1, world_pos.x, world_pos.y, inner_radius);
                    const inner_intensity = base_intensity * (0.8 + this.accretion_intensity * 0.3);
                    inner_grad.addColorStop(0, `rgba(255, 255, 200, ${inner_intensity * 0.9})`);
                    inner_grad.addColorStop(0.3, `rgba(255, 220, 100, ${inner_intensity * 0.8})`);
                    inner_grad.addColorStop(0.7, `rgba(255, 180, 50, ${inner_intensity * 0.6})`);
                    inner_grad.addColorStop(1, `rgba(255, 140, 0, ${inner_intensity * 0.3})`);
                    ctx.fillStyle = inner_grad;
                    ctx.beginPath();
                    ctx.arc(world_pos.x, world_pos.y, inner_radius, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Outer disk region - grows more dramatically
                    const outer_grad = ctx.createRadialGradient(world_pos.x, world_pos.y, inner_radius, world_pos.x, world_pos.y, disk_radius);
                    outer_grad.addColorStop(0, `rgba(255, 180, 50, ${base_intensity * 0.6})`);
                    outer_grad.addColorStop(0.4, `rgba(255, 140, 0, ${base_intensity * 0.5})`);
                    outer_grad.addColorStop(0.8, `rgba(255, 100, 0, ${base_intensity * 0.3})`);
                    outer_grad.addColorStop(1, `rgba(255, 50, 0, 0)`);
                    ctx.fillStyle = outer_grad;
                    ctx.beginPath();
                    ctx.arc(world_pos.x, world_pos.y, disk_radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            if (SETTINGS.show_bh_glow) {
                const glow_radius = world_radius * (1.8 + this.disk_growth * 0.4);
                const glow_intensity = 0.4 + this.accretion_intensity * 0.3;
                const grad = ctx.createRadialGradient(world_pos.x, world_pos.y, world_radius, world_pos.x, world_pos.y, glow_radius);
                grad.addColorStop(0, `rgba(200, 200, 255, ${glow_intensity})`);
                grad.addColorStop(1, `rgba(200, 200, 255, 0)`);
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(world_pos.x, world_pos.y, glow_radius, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Event horizon
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, world_radius, 0, 2 * Math.PI);
            ctx.fill();

            if (SETTINGS.show_bh_jets) {
                const jet_length = world_radius * (6 + this.jet_intensity * 2);
                const jet_width = Math.max(1 / state.zoom, world_radius * (0.15 + this.jet_intensity * 0.1));
                const jet_intensity = 0.6 + this.jet_intensity * 0.4;
                
                // Draw multiple jet layers for more realistic appearance
                const jet_layers = [
                    { width: jet_width * 0.3, color: `rgba(255, 255, 255, ${jet_intensity * 0.9})` },
                    { width: jet_width * 0.6, color: `rgba(255, 200, 100, ${jet_intensity * 0.7})` },
                    { width: jet_width, color: `rgba(255, 140, 0, ${jet_intensity * 0.5})` }
                ];
                
                // Draw jets in both directions
                for (const direction of [-1, 1]) {
                    for (const layer of jet_layers) {
                        ctx.fillStyle = layer.color;
                        ctx.fillRect(
                            world_pos.x - layer.width / 2, 
                            world_pos.y + direction * world_radius, 
                            layer.width, 
                            direction * jet_length
                        );
                    }
                    
                    // Add jet termination shock
                    const shock_radius = jet_width * (1.5 + this.jet_intensity * 0.5);
                    const shock_pos = {
                        x: world_pos.x,
                        y: world_pos.y + direction * (world_radius + jet_length)
                    };
                    
                    const shock_grad = ctx.createRadialGradient(
                        shock_pos.x, shock_pos.y, 0,
                        shock_pos.x, shock_pos.y, shock_radius
                    );
                    shock_grad.addColorStop(0, `rgba(255, 255, 255, ${jet_intensity * 0.6})`);
                    shock_grad.addColorStop(0.5, `rgba(255, 200, 100, ${jet_intensity * 0.4})`);
                    shock_grad.addColorStop(1, `rgba(255, 140, 0, 0)`);
                    
                    ctx.fillStyle = shock_grad;
                    ctx.beginPath();
                    ctx.arc(shock_pos.x, shock_pos.y, shock_radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            const true_screen_pos = {
                x: world_pos.x * state.zoom + canvas.width / 2 + state.pan.x,
                y: -world_pos.y * state.zoom + canvas.height / 2 + state.pan.y
            };

            const screen_radius = world_radius * state.zoom;
            let label_y_offset = screen_radius + 15;
            if (SETTINGS.show_bh_jets) label_y_offset = (screen_radius * 6) + screen_radius + 10;
            else if (SETTINGS.show_accretion_disk) label_y_offset = (screen_radius * 2.5) + 10;
            else if (SETTINGS.show_bh_glow) label_y_offset = (screen_radius * 1.8) + 10;

            ctx.font = '14px Roboto Mono';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 4;
            ctx.fillText(`${(this.mass / SOLAR_MASS_UNIT).toFixed(1)} Msun`, true_screen_pos.x, true_screen_pos.y + label_y_offset);
            
            ctx.restore();
        }
        
        get_state() { 
            return { 
                type: this.obj_type, 
                pos: this.pos, 
                vel: this.vel, 
                mass: this.mass,
                accretion_intensity: this.accretion_intensity,
                jet_intensity: this.jet_intensity,
                disk_growth: this.disk_growth,
                time_since_last_accretion: this.time_since_last_accretion
            }; 
        }
        set_state(s) { 
            this.pos = s.pos; 
            this.vel = s.vel; 
            this.mass = s.mass; 
            this.accretion_intensity = s.accretion_intensity || 0.0;
            this.jet_intensity = s.jet_intensity || 0.0;
            this.disk_growth = s.disk_growth || 0.0;
            this.time_since_last_accretion = s.time_since_last_accretion || 0.0;
            this.last_mass = this.mass;
            this.updateRadius(); 
        }
    }
    
    class Particle {
        constructor(pos, vel, lifetime = 0.8, start_size = 5, end_size = 1, color = 'rgb(255,255,100)') {
            this.pos = { ...pos }; this.vel = { ...vel }; this.lifetime = Math.max(0.1, lifetime);
            this.age = 0; this.start_size = start_size; this.end_size = end_size;
            this.color = color;
        }
        update(dt) {
            this.pos.x += this.vel.x * dt; this.pos.y += this.vel.y * dt; this.age += dt;
        }
        is_alive() { return this.age < this.lifetime; }
        draw(ctx) {
            const life_fraction = this.age / this.lifetime;
            const current_size = this.start_size * (1 - life_fraction) + this.end_size * life_fraction;
            const alpha = 1 - life_fraction;
            if (current_size < 1 || alpha < 0.05) return;
            const world_pos = world_to_screen(this.pos);
            ctx.fillStyle = this.color;
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, current_size / state.zoom, 0, 2 * Math.PI);
            ctx.fill();
        }
    }
    
    class GravityRipple {
        constructor(pos, mass_factor = 1.0) {
            this.pos = { ...pos };
            this.age = 0;
            this.lifetime = 3.0; // 3 seconds as requested
            this.max_radius = 200 * mass_factor; // Scale with mass
            this.start_radius = 10;
            this.pulse_count = 0;
            this.max_pulses = 5;
            this.pulse_interval = this.lifetime / this.max_pulses;
        }
        
        update(dt) {
            this.age += dt;
            this.pulse_count = Math.floor(this.age / this.pulse_interval);
        }
        
        is_alive() { 
            return this.age < this.lifetime; 
        }
        
        draw(ctx) {
            if (this.age >= this.lifetime) return;
            
            const world_pos = world_to_screen(this.pos);
            const life_fraction = this.age / this.lifetime;
            const base_alpha = 1 - life_fraction;
            
            // Draw multiple expanding rings
            for (let i = 0; i <= this.pulse_count && i < this.max_pulses; i++) {
                const pulse_age = this.age - (i * this.pulse_interval);
                const pulse_fraction = pulse_age / this.pulse_interval;
                
                if (pulse_fraction >= 0 && pulse_fraction <= 1) {
                    const current_radius = this.start_radius + (this.max_radius - this.start_radius) * pulse_fraction;
                    const pulse_alpha = base_alpha * (1 - pulse_fraction) * 0.6;
                    
                    if (pulse_alpha > 0.01) {
                        // Create radial gradient for the ripple
                        const gradient = ctx.createRadialGradient(
                            world_pos.x, world_pos.y, 0,
                            world_pos.x, world_pos.y, current_radius / state.zoom
                        );
                        
                        // Use gravitational wave colors (cyan/blue)
                        gradient.addColorStop(0, `rgba(0, 255, 255, ${pulse_alpha * 0.8})`);
                        gradient.addColorStop(0.3, `rgba(0, 200, 255, ${pulse_alpha * 0.6})`);
                        gradient.addColorStop(0.7, `rgba(0, 150, 255, ${pulse_alpha * 0.3})`);
                        gradient.addColorStop(1, `rgba(0, 100, 255, 0)`);
                        
                        ctx.fillStyle = gradient;
                        ctx.globalAlpha = 1;
                        ctx.beginPath();
                        ctx.arc(world_pos.x, world_pos.y, current_radius / state.zoom, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Add a subtle ring outline
                        ctx.strokeStyle = `rgba(0, 255, 255, ${pulse_alpha * 0.4})`;
                        ctx.lineWidth = 2 / state.zoom;
                        ctx.beginPath();
                        ctx.arc(world_pos.x, world_pos.y, current_radius / state.zoom, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                }
            }
        }
    }
    
    const handle_star_merging = (stars_list) => {
        let merged_this_step = true;
        let merge_count = 0;
        const max_merges_per_step = 3; // Prevent infinite loops
        
        while (merged_this_step && stars_list.length > 1 && merge_count < max_merges_per_step) {
            merged_this_step = false;
            
            // Create a copy of the stars list to avoid modifying during iteration
            const starsCopy = [...stars_list];
            
            for (let i = 0; i < starsCopy.length; i++) {
                for (let j = i + 1; j < starsCopy.length; j++) {
                    const star1 = starsCopy[i], star2 = starsCopy[j];
                    if (!star1.alive || !star2.alive) continue;
                    
                    const dx = star2.pos.x - star1.pos.x;
                    const dy = star2.pos.y - star1.pos.y;
                    const dist_sq = dx*dx + dy*dy;
                    const min_dist = star1.radius + star2.radius;
                    
                    if (dist_sq < min_dist**2 && dist_sq > 1e-6) {
                        // Calculate merged star properties
                        const m1 = star1.mass, m2 = star2.mass;
                        const total_mass = m1 + m2;
                        const new_mass_in_suns = total_mass / SOLAR_MASS_UNIT;
                        
                        // Center of mass position and velocity
                        const new_pos = { 
                            x: (star1.pos.x * m1 + star2.pos.x * m2) / total_mass, 
                            y: (star1.pos.y * m1 + star2.pos.y * m2) / total_mass 
                        };
                        const new_vel = { 
                            x: (star1.vel.x * m1 + star2.vel.x * m2) / total_mass, 
                            y: (star1.vel.y * m1 + star2.vel.y * m2) / total_mass 
                        };
                        
                        // Create explosion particles for the merger
                        for (let k = 0; k < 25; k++) {
                            const angle = Math.random() * 2 * Math.PI;
                            const speed = Math.random() * 80 + 40;
                            const p_vel = { 
                                x: speed * Math.cos(angle), 
                                y: speed * Math.sin(angle) 
                            };
                            const rgb = hexToRgb(star1.baseColor);
                            if (rgb) {
                                particles.push(new Particle(new_pos, p_vel, Math.random()*0.8+0.6, 8, 2, `rgb(${rgb.r},${rgb.g},${rgb.b})`));
                            } else {
                                particles.push(new Particle(new_pos, p_vel, Math.random()*0.8+0.6, 8, 2, 'rgb(255, 255, 100)'));
                            }
                        }
                        
                        // Create some debris from the merger
                        for (let k = 0; k < 8; k++) {
                            const angle = Math.random() * 2 * Math.PI;
                            const speed = Math.random() * 30 + 10;
                            const debris_vel = { 
                                x: speed * Math.cos(angle), 
                                y: speed * Math.sin(angle) 
                            };
                            const debris_pos = { 
                                x: new_pos.x + (Math.random() - 0.5) * 10, 
                                y: new_pos.y + (Math.random() - 0.5) * 10 
                            };
                            debris.push(new Debris(debris_pos, {x: new_vel.x + debris_vel.x, y: new_vel.y + debris_vel.y}));
                        }
                        
                        // Mark the original stars as dead (don't splice during iteration)
                        star1.alive = false;
                        star2.alive = false;
                        
                        // Determine the type of merger and create appropriate result
                        const star1Type = star1.obj_type || 'StarObject';
                        const star2Type = star2.obj_type || 'StarObject';
                        
                        // Handle white dwarf and neutron star mergers
                        if ((star1Type === 'WhiteDwarf' && star2Type === 'WhiteDwarf') ||
                            (star1Type === 'WhiteDwarf' && star2Type === 'NeutronStar') ||
                            (star1Type === 'NeutronStar' && star2Type === 'WhiteDwarf') ||
                            (star1Type === 'NeutronStar' && star2Type === 'NeutronStar')) {
                            
                            // White dwarf + white dwarf = neutron star (if mass allows) or black hole
                            // White dwarf + neutron star = neutron star or black hole
                            // Neutron star + neutron star = black hole
                            
                            if (new_mass_in_suns >= SETTINGS.max_star_mass_before_bh) {
                                // Create a black hole
                                bh_list.push(new BlackHole(new_pos, total_mass, new_vel));
                                
                                // Add dramatic particles for black hole formation
                                for (let k = 0; k < 40; k++) {
                                    const angle = Math.random() * 2 * Math.PI;
                                    const speed = Math.random() * 120 + 60;
                                    const p_vel = { 
                                        x: speed * Math.cos(angle), 
                                        y: speed * Math.sin(angle) 
                                    };
                                    particles.push(new Particle(new_pos, p_vel, Math.random()*1.0+0.8, 12, 3, 'rgb(255, 100, 0)'));
                                }
                            } else {
                                // Create a neutron star
                                const merged_neutron_star = new NeutronStar(new_pos, new_vel);
                                merged_neutron_star.mass = total_mass;
                                merged_neutron_star.massInSuns = total_mass / SOLAR_MASS_UNIT;
                                stars_list.push(merged_neutron_star);
                            }
                        } else {
                            // Regular star mergers
                            if (new_mass_in_suns >= SETTINGS.max_star_mass_before_bh) {
                                // Create a black hole from the merged star
                                bh_list.push(new BlackHole(new_pos, total_mass, new_vel));
                                
                                // Add more dramatic particles for black hole formation
                                for (let k = 0; k < 40; k++) {
                                    const angle = Math.random() * 2 * Math.PI;
                                    const speed = Math.random() * 120 + 60;
                                    const p_vel = { 
                                        x: speed * Math.cos(angle), 
                                        y: speed * Math.sin(angle) 
                                    };
                                    particles.push(new Particle(new_pos, p_vel, Math.random()*1.0+0.8, 12, 3, 'rgb(255, 100, 0)'));
                                }
                            } else {
                                // Create a new merged star
                                const merged_star = new StarObject(new_pos, new_vel, new_mass_in_suns);
                                stars_list.push(merged_star);
                            }
                        }
                        
                        merged_this_step = true;
                        merge_count++;
                        break;
                    }
                }
                if (merged_this_step) break;
            }
            
            // Filter out dead stars after processing all collisions
            stars_list = stars_list.filter(star => star.alive);
        }
    };

    const handle_collisions = (objects_list) => {
        for (let i = 0; i < objects_list.length; i++) {
            const obj1 = objects_list[i]; if (!obj1.alive) continue;
            for (let j = i + 1; j < objects_list.length; j++) {
                const obj2 = objects_list[j]; if (!obj2.alive) continue;
                const dx = obj2.pos.x - obj1.pos.x; const dy = obj2.pos.y - obj1.pos.y;
                const dist_sq = dx*dx + dy*dy; const min_dist = obj1.radius + obj2.radius;
                if (dist_sq < min_dist**2 && dist_sq > 1e-6) {
                    const dist = Math.sqrt(dist_sq); const overlap = min_dist - dist;
                    const nx = dx / dist; const ny = dy / dist;
                    const total_mass = obj1.mass + obj2.mass;
                    const move1 = -overlap * (obj2.mass / total_mass); const move2 = overlap * (obj1.mass / total_mass);
                    obj1.pos.x += move1 * nx; obj1.pos.y += move1 * ny;
                    obj2.pos.x += move2 * nx; obj2.pos.y += move2 * ny;
                    const rvx = obj2.vel.x - obj1.vel.x; const rvy = obj2.vel.y - obj1.vel.y;
                    const vel_normal = rvx * nx + rvy * ny;
                    if (vel_normal < 0) {
                        const e = 0.8;
                        const j = -(1 + e) * vel_normal / (1/obj1.mass + 1/obj2.mass);
                        const impx = j * nx; const impy = j * ny;
                        obj1.vel.x -= impx / obj1.mass; obj1.vel.y -= impy / obj1.mass;
                        obj2.vel.x += impx / obj2.mass; obj2.vel.y += impy / obj2.mass;
                    }
                }
            }
        }
    }

    // Handle collisions between stars and smaller objects (planets, gas giants, asteroids, comets)
    const handle_star_object_collisions = () => {
        // Use filter to safely remove objects without modifying arrays during iteration
        const originalPlanets = [...planets];
        const originalGasGiants = [...gas_giants];
        const originalAsteroids = [...asteroids];
        
        // Check collisions between stars and planets
        for (let i = 0; i < stars.length; i++) {
            const star = stars[i];
            if (!star.alive) continue;
            
            // Check with planets
            for (let j = 0; j < originalPlanets.length; j++) {
                const planet = originalPlanets[j];
                if (!planet.alive) continue;
                
                const dx = planet.pos.x - star.pos.x;
                const dy = planet.pos.y - star.pos.y;
                const dist_sq = dx*dx + dy*dy;
                const min_dist = star.radius + planet.radius;
                
                if (dist_sq < min_dist**2 && dist_sq > 1e-6) {
                    // Star absorbs the planet
                    star.mass += planet.mass;
                    if (star.obj_type === 'NeutronStar') {
                        // Neutron stars have nearly constant radius, but update mass
                        star.massInSuns = star.mass / SOLAR_MASS_UNIT;
                    } else if (star.obj_type === 'WhiteDwarf') {
                        // White dwarfs have nearly constant radius, but update mass
                        star.massInSuns = star.mass / SOLAR_MASS_UNIT;
                    } else if (star.obj_type === 'StarObject') {
                        star.massInSuns = star.mass / SOLAR_MASS_UNIT;
                        // Update radius for regular stars
                        star.radius = STAR_OBJ_RADIUS * Math.pow(star.massInSuns, 0.85);
                    }
                    
                    // Create some debris and particles
                    for (let k = 0; k < 5; k++) {
                        const angle = Math.random() * 2 * Math.PI;
                        const speed = Math.random() * 20 + 10;
                        const p_vel = { 
                            x: speed * Math.cos(angle), 
                            y: speed * Math.sin(angle) 
                        };
                        particles.push(new Particle(planet.pos, p_vel, Math.random()*0.5+0.3, 4, 1, 'rgb(255, 200, 100)'));
                    }
                    
                    planet.alive = false;
                }
            }
            
            // Check with gas giants
            for (let j = 0; j < originalGasGiants.length; j++) {
                const gasGiant = originalGasGiants[j];
                if (!gasGiant.alive) continue;
                
                const dx = gasGiant.pos.x - star.pos.x;
                const dy = gasGiant.pos.y - star.pos.y;
                const dist_sq = dx*dx + dy*dy;
                const min_dist = star.radius + gasGiant.radius;
                
                if (dist_sq < min_dist**2 && dist_sq > 1e-6) {
                    // Star absorbs the gas giant
                    star.mass += gasGiant.mass;
                    if (star.obj_type === 'NeutronStar') {
                        // Neutron stars have nearly constant radius, but update mass
                        star.massInSuns = star.mass / SOLAR_MASS_UNIT;
                    } else if (star.obj_type === 'WhiteDwarf') {
                        // White dwarfs have nearly constant radius, but update mass
                        star.massInSuns = star.mass / SOLAR_MASS_UNIT;
                    } else if (star.obj_type === 'StarObject') {
                        star.massInSuns = star.mass / SOLAR_MASS_UNIT;
                        // Update radius for regular stars
                        star.radius = STAR_OBJ_RADIUS * Math.pow(star.massInSuns, 0.85);
                    }
                    
                    // Create more dramatic debris and particles for gas giant
                    for (let k = 0; k < 8; k++) {
                        const angle = Math.random() * 2 * Math.PI;
                        const speed = Math.random() * 30 + 15;
                        const p_vel = { 
                            x: speed * Math.cos(angle), 
                            y: speed * Math.sin(angle) 
                        };
                        particles.push(new Particle(gasGiant.pos, p_vel, Math.random()*0.6+0.4, 6, 2, 'rgb(135, 206, 235)'));
                    }
                    
                    gasGiant.alive = false;
                }
            }
            
            // Check with asteroids and comets
            for (let j = 0; j < originalAsteroids.length; j++) {
                const asteroid = originalAsteroids[j];
                if (!asteroid.alive) continue;
                
                const dx = asteroid.pos.x - star.pos.x;
                const dy = asteroid.pos.y - star.pos.y;
                const dist_sq = dx*dx + dy*dy;
                const min_dist = star.radius + asteroid.radius;
                
                if (dist_sq < min_dist**2 && dist_sq > 1e-6) {
                    // Star absorbs the asteroid/comet
                    star.mass += asteroid.mass;
                    if (star.obj_type === 'NeutronStar') {
                        // Neutron stars have nearly constant radius, but update mass
                        star.massInSuns = star.mass / SOLAR_MASS_UNIT;
                    } else if (star.obj_type === 'WhiteDwarf') {
                        // White dwarfs have nearly constant radius, but update mass
                        star.massInSuns = star.mass / SOLAR_MASS_UNIT;
                    } else if (star.obj_type === 'StarObject') {
                        star.massInSuns = star.mass / SOLAR_MASS_UNIT;
                        // Update radius for regular stars
                        star.radius = STAR_OBJ_RADIUS * Math.pow(star.massInSuns, 0.85);
                    }
                    
                    // Create small debris
                    for (let k = 0; k < 3; k++) {
                        const angle = Math.random() * 2 * Math.PI;
                        const speed = Math.random() * 15 + 5;
                        const p_vel = { 
                            x: speed * Math.cos(angle), 
                            y: speed * Math.sin(angle) 
                        };
                        particles.push(new Particle(asteroid.pos, p_vel, Math.random()*0.4+0.2, 3, 1, 'rgb(139, 69, 19)'));
                    }
                    
                    asteroid.alive = false;
                }
            }
        }
        
        // Filter out dead objects (this is safe and already done elsewhere in the code)
        planets = planets.filter(planet => planet.alive);
        gas_giants = gas_giants.filter(gasGiant => gasGiant.alive);
        asteroids = asteroids.filter(asteroid => asteroid.alive);
    };

    const apply_preset = (settings_dict) => {
        const ps = settings_dict.preset_scenario;
        if (ps === "None") return;
        const fresh_defaults = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
        Object.assign(settings_dict, fresh_defaults, { preset_scenario: ps });

        if (ps === "Binary BH") { Object.assign(settings_dict, { num_black_holes: 2, bh_behavior: "Orbiting", use_individual_bh_masses: true, bh_masses: [15, 10], num_planets: 10, num_asteroids: 30, placement: "Circular", init_velocity: 15 }); }
        else if (ps === "Triple BH System") { Object.assign(settings_dict, { num_black_holes: 3, bh_behavior: "Orbiting", use_individual_bh_masses: true, bh_masses: [20, 15, 10], num_planets: 20, num_asteroids: 40, placement: "Circular", init_velocity: 10, orbit_decay_rate: 0.001 }); }
        else if (ps === "Supermassive BH") { Object.assign(settings_dict, { num_black_holes: 1, bh_mass: 80, num_planets: 50, num_gas_giants: 5, num_asteroids: 100, init_velocity: 25, show_accretion_disk: true }); }
        else if (ps === "Star Cluster") { Object.assign(settings_dict, { num_black_holes: 0, num_planets: 100, num_gas_giants: 10, num_asteroids: 200, placement: "Grid", init_velocity: 5, gravitational_constant: 1.0 }); }
        else if (ps === "Kuiper Belt") { Object.assign(settings_dict, { placement: "Empty", mutual_gravity: true, num_black_holes: 0, num_planets: 8, num_gas_giants: 4, enable_asteroids: true, num_asteroids: 300 }); }
        else if (ps === "Sagittarius A*") { Object.assign(settings_dict, { num_black_holes: 1, bh_mass: 1000, bh_behavior: "Static", show_accretion_disk: true, show_bh_glow: true, num_planets: 200, num_gas_giants: 10, num_asteroids: 50, placement: "Random", init_velocity: 60, velocity_stddev: 20 }); }
        else if (ps === "Binary Star System") { Object.assign(settings_dict, { num_black_holes: 0, mutual_gravity: true, placement: "Empty", num_planets: 5 }); }
        else if (ps === "Slingshot") { Object.assign(settings_dict, { placement: "Empty", num_black_holes: 2, use_individual_bh_masses: true, bh_masses: [50, 2], bh_behavior: "Orbiting", num_planets: 15 }); }
        else if (ps === "Rogue Encounter") { Object.assign(settings_dict, { placement: "Empty", num_black_holes: 1, bh_mass: 25, mutual_gravity: true, num_planets: 8, num_gas_giants: 2 }); }
		else if (ps === "Galactic Collision"){
			Object.assign(settings_dict,{
				num_black_holes:2, bh_masses:[1500,1500], use_individual_bh_masses:true,
				bh_behavior:"Orbiting", num_planets:800, num_gas_giants:80,
				placement:"Random", init_velocity:80, velocity_stddev:40,
				enable_asteroids:false,
				galactic_collision_special:true // Custom flag for placement
			});
		}
		else if (ps === "Micro BH Swarm"){
			Object.assign(settings_dict,{
				num_black_holes:20, bh_mass:2, bh_behavior:"Orbiting",
				num_planets:0, num_gas_giants:0, enable_asteroids:false,
				placement:"Random", init_velocity:0, velocity_stddev:0,
				gravitational_constant:4.0
			});
		}
		else if (ps === "Exoplanet Lab"){
			Object.assign(settings_dict,{
				num_black_holes:0, num_planets:100, num_gas_giants:15,
				placement:"Multi-Ring", init_velocity:25, velocity_stddev:5,
				mutual_gravity:true, enable_asteroids:false
			});
		}
		else if (ps === "Solar System Lite") {
			Object.assign(settings_dict, {
				num_black_holes: 0, num_planets: 8, num_gas_giants: 0, enable_asteroids: true, num_asteroids: 200, bh_behavior: "Static", placement: "Circular", init_velocity: 15, sim_speed: 0.5
			});
		}
		else if (ps === "Double Pulsar") {
			Object.assign(settings_dict, {
				num_black_holes: 0, num_planets: 5, num_gas_giants: 0, enable_asteroids: false, bh_behavior: "Static", placement: "Empty", init_velocity: 35, sim_speed: 1.0
			});
		}
		else if (ps === "Sag A* Neighborhood") {
			Object.assign(settings_dict, {
				num_black_holes: 1, bh_mass: 4e6, num_planets: 0, num_gas_giants: 0, enable_asteroids: false, placement: "Random", init_velocity: 500, sim_speed: 0.2, show_accretion_disk: true, show_bh_glow: true
			});
		}
		else if (ps === "Galactic Bar") {
			Object.assign(settings_dict, {
				num_black_holes: 5, bh_behavior: "Orbiting", use_individual_bh_masses: true, bh_masses: [10, 8, 12, 9, 11], num_planets: 40, num_gas_giants: 6, placement: "Empty", init_velocity: 30, orbit_decay_rate: 0.0, sim_speed: 0.7
			});
		}
		else if (ps === "Quasar Feast") {
			Object.assign(settings_dict, {
				num_black_holes: 1, bh_mass: 100, num_planets: 0, num_gas_giants: 0, enable_asteroids: true, num_asteroids: 800, show_accretion_disk: true, show_bh_glow: true, placement: "Random", init_velocity: 5, sim_speed: 0.4
			});
		}
		else if (ps === "Trappist-1x") {
			Object.assign(settings_dict, {
				num_black_holes: 0, num_planets: 7, num_gas_giants: 0, placement: "Circular", init_velocity: 8, velocity_stddev: 1, sim_speed: 0.6
			});
		}
		else if (ps === "Rogue Planet Cloud") {
			Object.assign(settings_dict, {
				num_black_holes: 0, num_planets: 200, num_gas_giants: 0, enable_asteroids: false, placement: "Random", init_velocity: 3, velocity_stddev: 2, sim_speed: 1.0
			});
		}
		else if (ps === "Dyson Swarm") {
			Object.assign(settings_dict, {
				num_black_holes: 0, num_planets: 0, num_gas_giants: 0, enable_asteroids: true, num_asteroids: 100, placement: "Empty", init_velocity: 10, sim_speed: 0.5
			});
		}
		else if (ps === "Wormhole Chase") {
			Object.assign(settings_dict, {
				num_black_holes: 2, bh_behavior: "Static", use_individual_bh_masses: true, bh_masses: [15, 15], num_planets: 30, enable_asteroids: true, num_asteroids: 150, placement: "Circular", init_velocity: 20, sim_speed: 0.8
			});
		}
		else if (ps === "Ringworld Mayhem") {
			Object.assign(settings_dict, {
				num_black_holes: 1, bh_mass: 0, num_planets: 0, num_gas_giants: 0, enable_asteroids: true, num_asteroids: 1200, placement: "Empty", init_velocity: 9, velocity_stddev: 0.5, sim_speed: 0.9
			});
		}

        settings_dict.preset_scenario = "None";
    }

        let current_scenario_name = null; // Store the current scenario name

    /* ----------  human-friendly titles & summaries  ---------- */
    const SCENARIO_INFO = {
        "Binary BH":           {
        title:"Binary Black Hole", 
        summary:"Two stellar-mass black holes (15 & 10 M☉) locked in mutual orbit. Watch as they spiral together, creating gravitational waves and eventually merging into a single, more massive black hole. Perfect for studying orbital dynamics and merger events."
      },
      "Triple BH System":    {
        title:"Triple Black Hole",  
        summary:"A chaotic three-body dance of massive black holes (20, 15, & 10 M☉) in a complex orbital arrangement. This unstable configuration will eventually eject one black hole while the remaining two merge. Demonstrates the chaotic nature of multi-body gravitational systems."
      },
      "Supermassive BH":     {
        title:"Supermassive Core",  
        summary:"One enormous black hole (80 M☉) dominates a dense stellar swarm with 50 planets, 5 gas giants, and 100 asteroids. The intense gravitational field creates spectacular accretion disks and tidal disruption events. Similar to the environment around real supermassive black holes in galactic centers."
      },
      "Star Cluster":        {
        title:"Dense Star Cluster", 
        summary:"Hundreds of stars (100 planets, 10 gas giants, 200 asteroids) with gentle mutual gravity in a black hole-free environment. Watch as stars interact, potentially forming binary systems or experiencing close encounters. Represents a young open cluster or globular cluster core."
      },
      "Kuiper Belt":         {
        title:"Kuiper Belt",        
        summary:"A sun-like star with outer-system objects including 8 planets, 4 gas giants, and 300 asteroids in distant orbits. The system mimics our Solar System's Kuiper Belt region, with icy bodies and dwarf planets orbiting far from the central star."
      },
      "Sagittarius A*":      {title:"Sagittarius A*",     summary:"The Milky Way's central BH and its surrounding stars."},
      "Binary Star System":  {
        title:"Binary Stars",       
        summary:"A pair of suns in mutual orbit with 5 planets orbiting the binary system. The complex gravitational environment creates interesting orbital dynamics and potential habitable zones. Similar to real binary star systems like Alpha Centauri."
      },
      "Slingshot":           {
        title:"Gravity Slingshot",  
        summary:"Use a heavy black hole (50 M☉) to fling lighter bodies across the system. A smaller black hole (2 M☉) approaches at high velocity, creating dramatic gravitational assists. Demonstrates the slingshot effect used by spacecraft to gain velocity from planetary encounters."
      },
      "Rogue Encounter":     {
        title:"Rogue Encounter",    
        summary:"A wandering black hole (25 M☉) grazes a stable planetary system with 8 planets and 2 gas giants. Watch as the rogue black hole disrupts orbits, potentially ejecting planets or creating new orbital configurations. Shows the chaos that can occur when massive objects pass through planetary systems."
      },
      "Galactic Collision":  {
        title:"Galactic Collision", 
        summary:"Two supermassive black holes (1500 M☉ each) with thousands of stars (800 planets, 80 gas giants) on a collision course. This massive-scale simulation represents the merger of two galaxies, with the black holes eventually coalescing and stars being scattered throughout the new system."
      },
      "Micro BH Swarm":      {
        title:"Micro BH Swarm",     
        summary:"Dozens of tiny black holes (20 BHs of 2 M☉ each) interacting chaotically in a high-gravity environment. The black holes orbit each other, merge, and create complex gravitational patterns. Represents a theoretical population of primordial black holes or the aftermath of multiple stellar collapses."
      },
      "Exoplanet Lab":       {
        title:"Exoplanet Lab",      
        summary:"A sun-like star with 100+ varied planets and 15 gas giants arranged in multiple orbital rings. Perfect for studying planetary dynamics, orbital resonances, and the stability of multi-planet systems. Similar to real exoplanet systems like TRAPPIST-1 or Kepler-90."
      },
      "Solar System Lite":   {
        title:"Solar System Lite", 
        summary:"A single sun with eight worlds and 200 asteroids — a simplified playground for Kepler's laws. Watch as planets follow elliptical orbits with the sun at one focus, demonstrating orbital mechanics and the stability of our own Solar System's architecture."
      },
      "Double Pulsar":       {
        title:"Double Pulsar", 
        summary:"Two 1.4 M☉ neutron stars orbit each other in a tight binary system with 5 planets. The intense gravitational field and rapid orbital motion create extreme tidal forces. Can you keep planets stable in this chaotic environment? Based on real binary pulsar systems like PSR B1913+16."
      },
      "Sag A* Neighborhood": {
        title:"Sag A* Neighborhood", 
        summary:"Super-massive black hole (4 × 10⁶ M☉) with high-speed stars whizzing around every few hours. The extreme gravitational environment creates relativistic effects and rapid orbital periods. Represents the environment around Sagittarius A*, the black hole at the center of our Milky Way galaxy."
      },
      "Galactic Bar":        {
        title:"Galactic Bar", 
        summary:"Five medium black holes (10, 8, 12, 9, 11 M☉) arranged in a rotating bar formation with 40 planets and 6 gas giants. The bar structure creates unique orbital dynamics and can drive material toward the center. Represents the bar structure found in many spiral galaxies like our own Milky Way."
      },
      "Quasar Feast":        {
        title:"Quasar Feast", 
        summary:"A feeding 100 M☉ black hole with a dense debris disk of 800 asteroids. Watch as material spirals into the black hole, creating spectacular accretion events and particle jets. Represents the active phase of a quasar, where a supermassive black hole actively consumes surrounding material."
      },
      "Trappist-1x":         {
        title:"Trappist-1x", 
        summary:"Seven Earth-size planets in tight resonant orbits around a red dwarf star. The planets are packed closely together, creating complex gravitational interactions and potential orbital resonances. Based on the real TRAPPIST-1 system, which has seven Earth-sized planets orbiting a cool red dwarf."
      },
      "Rogue Planet Cloud":  {
        title:"Rogue Planet Cloud", 
        summary:"A dark, black hole-free sector filled with 200 wandering planets. These rogue planets travel through interstellar space without orbiting any star. Can gravity self-organize them into temporary clusters or binary systems? Represents the theoretical population of free-floating planets in our galaxy."
      },
      "Dyson Swarm":         {
        title:"Dyson Swarm", 
        summary:"100 tiny solar-collectors in Keplerian orbit around a central mass. This megastructure concept involves many small satellites collecting energy from a star. Tinker with the stability of these orbital structures and watch how they interact gravitationally. Based on the theoretical Dyson swarm concept for harvesting stellar energy."
      },
      "Wormhole Chase":      {
        title:"Wormhole Chase", 
        summary:"Two black holes (15 M☉ each) linked by a fictional wormhole connection. Planets can be flung between the black holes, creating interesting orbital dynamics. While wormholes are theoretical, this scenario explores the gravitational effects of having two massive objects connected by a shortcut through spacetime."
      },
      "Ringworld Mayhem":    {
        title:"Ringworld Mayhem", 
        summary:"Ultra-massive ring of 1200 asteroids with a central massless black hole. The ring structure is inherently unstable and will collapse under its own gravity. Watch as the ring fragments and reorganizes, demonstrating the instability of large-scale ring structures in space. Inspired by Larry Niven's Ringworld concept."
      },
      "Neutron Star Binary": {
        title:"Neutron Star Binary", 
        summary:"Two neutron stars (1.4 & 1.3 M☉) in a tight binary orbit with planets in distant orbits. These incredibly dense stellar remnants create extreme gravitational fields and may eventually merge to form a black hole. Based on real binary neutron star systems like PSR B1913+16, which provided the first indirect evidence of gravitational waves."
      },
      "White Dwarf Cluster": {
        title:"White Dwarf Cluster", 
        summary:"A cluster of eight white dwarfs with varying masses (0.6-1.4 M☉) orbiting a common center. These stellar remnants are the final evolutionary state of stars like our Sun. Watch as they interact gravitationally, potentially forming binary systems or experiencing close encounters. Represents the dense core of an old globular cluster."
      },
      "Comet Storm":         {
        title:"Comet Storm", 
        summary:"A central star surrounded by 50 comets with spectacular tails, plus several planets. The comets follow highly elliptical orbits and create beautiful visual effects as they approach the star. Watch as comets interact with planets and each other, creating a dynamic and chaotic environment similar to the early Solar System."
      },
      "Compact Object Dance": {
        title:"Compact Object Dance", 
        summary:"A central black hole (20 M☉) with three neutron stars and four white dwarfs in orbital ballet, plus 20 comets for visual flair. This extreme environment showcases the different types of stellar remnants and their interactions. The intense gravitational fields create complex orbital dynamics and potential merger events."
      }
    };

    const show_scenario_info = () => {
        const scenarioInfoDiv = document.getElementById('scenarioInfoDisplay');
        
        if (current_scenario_name && current_scenario_name !== 'None' && SCENARIO_INFO[current_scenario_name]) {
            const info = SCENARIO_INFO[current_scenario_name];
            scenarioInfoDiv.innerHTML = `<h4>${info.title}</h4><p>${info.summary}</p>`;
            scenarioInfoDiv.classList.add('visible');
            setTimeout(() => scenarioInfoDiv.classList.remove('visible'), 6000);
        } else {
            scenarioInfoDiv.classList.remove('visible');
        }
    };

    const initialize_simulation = () => {
        const starting_preset = SETTINGS.preset_scenario;
        apply_preset(SETTINGS);
        current_scenario_name = starting_preset; // Always set after apply_preset

        state.zoom = 1.0; state.pan = { x: 0.0, y: 0.0 };
        bh_list = []; planets = []; stars = []; gas_giants = []; asteroids = [];
        debris = []; particles = []; gravity_ripples = []; PhysicsObject_id_counter = 0;

        // --- Add central stars for specific presets that need them BEFORE general placement ---
        if (["Kuiper Belt", "Rogue Encounter", "Exoplanet Lab", "Solar System Lite", "Trappist-1x"].includes(starting_preset)) {
            stars.push(new StarObject({ x: 0, y: 0 }, { x: 0, y: 0 }, 1.0)); // Add a 1 Msun star
        }

        // --- Handle special setup presets that have their own placement logic ---
        if (starting_preset === "Binary Star System") {
            stars.push(new StarObject({x: -50, y: 0}, {x: 0, y: 10})); // These get random mass/size/color
            stars.push(new StarObject({x: 50, y: 0}, {x: 0, y: -10}));
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 250 + Math.random() * 50;
                const theta = Math.random() * 2 * Math.PI;
                planets.push(new Planet({x: r * Math.cos(theta), y: r*Math.sin(theta)}, {x:0, y:0}));
            }
        } else if (starting_preset === "Kuiper Belt") {
            const central_mass = stars[0].mass;
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 50 + i * 25;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                planets.push(new Planet({x: r, y:0}, {x:0, y:v}));
            }
            for(let i=0; i < SETTINGS.num_gas_giants; i++) {
                const r = 250 + i * 50;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                gas_giants.push(new GasGiant({x: r, y:0}, {x:0, y:v * 0.8}));
            }
            if (SETTINGS.enable_asteroids) {
                for (let i = 0; i < SETTINGS.num_asteroids; i++) {
                    const r = 400 + Math.random() * 150;
                    const theta = Math.random() * 2 * Math.PI;
                    const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                    const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                    asteroids.push(new Asteroid(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }));
                }
            }
        } else if (starting_preset === "Rogue Encounter") {
            const central_mass = stars[0].mass;
            for(let i=0; i<SETTINGS.num_planets; i++) {
                const r = 50 + i * 20;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                planets.push(new Planet({x: r, y:0}, {x:0, y:v}));
            }
            bh_list.push(new BlackHole({x: -1000, y: 300}, 25 * SOLAR_MASS_UNIT, {x: 15, y: -5}));
        } else if (starting_preset === "Triple BH System") {
            const m = SETTINGS.bh_masses;
            const mass1 = m && m.length > 0 ? m[0] : 20;
            const mass2 = m && m.length > 1 ? m[1] : 15;
            const mass3 = m && m.length > 2 ? m[2] : 10;
            bh_list.push(new BlackHole({x: 0, y: 150}, mass1 * SOLAR_MASS_UNIT, {x: -12, y: 0}));
            bh_list.push(new BlackHole({x: -130, y: -75}, mass2 * SOLAR_MASS_UNIT, {x: 6, y: -10}));
            bh_list.push(new BlackHole({x: 130, y: -75}, mass3 * SOLAR_MASS_UNIT, {x: 6, y: 10}));
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 450 + Math.random() * 100;
                const theta = Math.random() * 2 * Math.PI;
                planets.push(new Planet({x: r * Math.cos(theta), y: r*Math.sin(theta) }, {x:0, y:0}));
            }
        } else if (starting_preset === "Slingshot") {
            bh_list.push(new BlackHole({x: 0, y: 0}, 50 * SOLAR_MASS_UNIT, {x: 0, y: -0.5}));
            bh_list.push(new BlackHole({x: -800, y: 150}, 2 * SOLAR_MASS_UNIT, {x: 35, y: 0}));
            for(let i=0; i<SETTINGS.num_planets; i++) {
                const r = Math.random()*200 + 100;
                const theta = Math.random() * Math.PI * 2;
                planets.push(new Planet({x: r*Math.cos(theta), y: r*Math.sin(theta)}, {x:0, y:0}));
            }
        } else if (starting_preset === "Solar System Lite") {
            const central_mass = stars[0].mass;
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 50 + i * 30;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                planets.push(new Planet({x: r, y:0}, {x:0, y:v}));
            }
            if (SETTINGS.enable_asteroids) {
                for (let i = 0; i < SETTINGS.num_asteroids; i++) {
                    const r = 300 + Math.random() * 200;
                    const theta = Math.random() * 2 * Math.PI;
                    const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                    const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                    asteroids.push(new Asteroid(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }));
                }
            }
        } else if (starting_preset === "Double Pulsar") {
            // Add two neutron stars in tight orbit
            stars.push(new NeutronStar({x: -15, y: 0}, {x: 0, y: 25}, 1.4));
            stars.push(new NeutronStar({x: 15, y: 0}, {x: 0, y: -25}, 1.4));
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 200 + Math.random() * 100;
                const theta = Math.random() * 2 * Math.PI;
                planets.push(new Planet({x: r * Math.cos(theta), y: r*Math.sin(theta)}, {x:0, y:0}));
            }
        } else if (starting_preset === "Trappist-1x") {
            const central_mass = stars[0].mass * 0.09; // Red dwarf mass
            stars[0].mass = central_mass; // Update the star's mass
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 20 + i * 8; // Tight orbits like Trappist-1
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                planets.push(new Planet({x: r, y:0}, {x:0, y:v}));
            }
        } else if (starting_preset === "Dyson Swarm") {
            // Create 100 small satellites in orbit around the center
            for(let i=0; i < SETTINGS.num_asteroids; i++) {
                const r = 50 + Math.random() * 100;
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * 1000) / r); // Use a central mass
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                const asteroid = new Asteroid(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) });
                asteroid.radius = 1; // Make them smaller like satellites
                asteroids.push(asteroid);
            }
        } else if (starting_preset === "Sag A* Neighborhood") {
            // Add high-speed S-stars around the supermassive black hole
            for(let i=0; i < 20; i++) {
                const r = 50 + Math.random() * 200;
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * SETTINGS.bh_mass * SOLAR_MASS_UNIT) / r);
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                const star = new StarObject(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }, 0.5 + Math.random() * 2.0);
                stars.push(star);
            }
        } else if (starting_preset === "Galactic Bar") {
            // Create a bar formation of 5 black holes
            const bar_length = 200;
            const bar_width = 40;
            const masses = SETTINGS.bh_masses;
            const defaultMasses = [10, 8, 12, 9, 11];
            for(let i=0; i < 5; i++) {
                const x = (i - 2) * bar_length / 4; // Spread across the bar
                const y = (Math.random() - 0.5) * bar_width;
                const orbit_speed = 8;
                const angle = Math.atan2(y, x);
                const vel = {x: -orbit_speed * Math.sin(angle), y: orbit_speed * Math.cos(angle)};
                const mass = masses && masses.length > i ? masses[i] : defaultMasses[i];
                bh_list.push(new BlackHole({x: x, y: y}, mass * SOLAR_MASS_UNIT, vel));
            }
        } else if (starting_preset === "Ringworld Mayhem") {
            // Create a massive ring of asteroids with a central "hole" (0 mass BH)
            bh_list.push(new BlackHole({x: 0, y: 0}, 0 * SOLAR_MASS_UNIT)); // 0 mass black hole
            for(let i=0; i < SETTINGS.num_asteroids; i++) {
                const r = 150 + Math.random() * 50; // Ring formation
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * 1000) / r); // Use some central mass for orbital velocity
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                asteroids.push(new Asteroid(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }));
            }
        } else if (starting_preset === "Neutron Star Binary") {
            // Create a binary system of two neutron stars
            stars.push(new NeutronStar({x: -20, y: 0}, {x: 0, y: 15}, 1.4));
            stars.push(new NeutronStar({x: 20, y: 0}, {x: 0, y: -15}, 1.3));
            // Add some planets in distant orbits
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 300 + Math.random() * 200;
                const theta = Math.random() * 2 * Math.PI;
                planets.push(new Planet({x: r * Math.cos(theta), y: r*Math.sin(theta)}, {x:0, y:0}));
            }
        } else if (starting_preset === "White Dwarf Cluster") {
            // Create a cluster of white dwarfs
            for(let i=0; i < 8; i++) {
                const r = 100 + Math.random() * 150;
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * 1000) / r);
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                const mass = 0.6 + Math.random() * 0.8; // White dwarf mass range
                stars.push(new WhiteDwarf(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }, mass));
            }
            // Add some planets and asteroids
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 400 + Math.random() * 200;
                const theta = Math.random() * 2 * Math.PI;
                planets.push(new Planet({x: r * Math.cos(theta), y: r*Math.sin(theta)}, {x:0, y:0}));
            }
            if (SETTINGS.enable_asteroids) {
                for (let i = 0; i < SETTINGS.num_asteroids; i++) {
                    const r = 600 + Math.random() * 300;
                    const theta = Math.random() * 2 * Math.PI;
                    const v = Math.sqrt((SETTINGS.gravitational_constant * 1000) / r);
                    const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                    asteroids.push(new Asteroid(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }));
                }
            }
        } else if (starting_preset === "Comet Storm") {
            // Create a storm of comets with a central star
            stars.push(new StarObject({ x: 0, y: 0 }, { x: 0, y: 0 }, 1.0));
            const central_mass = stars[0].mass;
            for(let i=0; i < 50; i++) {
                const r = 200 + Math.random() * 400;
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r) * (0.8 + Math.random() * 0.4);
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                asteroids.push(new Comet(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }));
            }
            // Add some planets
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 50 + i * 20;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                planets.push(new Planet({x: r, y:0}, {x:0, y:v}));
            }
        } else if (starting_preset === "Compact Object Dance") {
            // Create a mix of compact objects (neutron stars, white dwarfs) with a central black hole
            bh_list.push(new BlackHole({x: 0, y: 0}, 20 * SOLAR_MASS_UNIT));
            const central_mass = bh_list[0].mass;
            
            // Add neutron stars
            for(let i=0; i < 3; i++) {
                const r = 80 + i * 40;
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                const mass = 1.2 + Math.random() * 1.0;
                stars.push(new NeutronStar(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }, mass));
            }
            
            // Add white dwarfs
            for(let i=0; i < 4; i++) {
                const r = 150 + i * 30;
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                const mass = 0.5 + Math.random() * 0.9;
                stars.push(new WhiteDwarf(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }, mass));
            }
            
            // Add some comets for visual interest
            for(let i=0; i < 20; i++) {
                const r = 300 + Math.random() * 200;
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                asteroids.push(new Comet(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }));
            }
        } else {
             // --- Standard placement logic for all other presets ---
            const num_bh = SETTINGS.num_black_holes;
            if (num_bh === 1 && bh_list.length === 0) { bh_list.push(new BlackHole({x:0, y:0}, SETTINGS.bh_mass * SOLAR_MASS_UNIT)); } 
            else if (num_bh > 1) {
                const masses = (SETTINGS.use_individual_bh_masses && SETTINGS.bh_masses.length === num_bh) ? SETTINGS.bh_masses : Array(num_bh).fill(SETTINGS.bh_mass);
                const bh_initial_radius = 150;
                for (let i = 0; i < num_bh; i++) {
                    const angle = 2 * Math.PI * i / num_bh;
                    const pos = {x: bh_initial_radius * Math.cos(angle), y: bh_initial_radius * Math.sin(angle)};
                    let vel = {x: 0, y: 0};
                    if (SETTINGS.bh_behavior === "Orbiting") {
                        const orbit_speed = 8;
                        vel = {x: -orbit_speed * Math.sin(angle), y: orbit_speed * Math.cos(angle)};
                    }
                    bh_list.push(new BlackHole(pos, masses[i] * SOLAR_MASS_UNIT, vel));
                }
            }
            
            const central_body = (stars.length === 1 && bh_list.length === 0) ? stars[0] : 
                                 (bh_list.length === 1 && stars.length === 0) ? bh_list[0] : null;

            const get_orbital_velocity = (pos, center_obj) => {
                const r_vec = { x: pos.x - (center_obj?.pos.x || 0), y: pos.y - (center_obj?.pos.y || 0) };
                const r = Math.hypot(r_vec.x, r_vec.y);
                if (r < 1) return {x:0, y:0};

                let vel_mag;
                if (center_obj) { // Calculate proper orbital velocity
                    vel_mag = Math.sqrt(SETTINGS.gravitational_constant * center_obj.mass / r);
                } else { // Fallback to user setting for chaotic systems
                    vel_mag = SETTINGS.init_velocity + (Math.random() - 0.5) * 2 * SETTINGS.velocity_stddev;
                }
                return { x: -vel_mag * (r_vec.y / r), y: vel_mag * (r_vec.x / r) };
            };
            
            const min_radius = (num_bh > 0 || stars.length > 0) ? 100 : 50;
            const max_radius = { "Small": 200, "Medium": 300, "Large": 400, "Huge": 500 }[SETTINGS.sim_size] || 400;

            const placementFunc = (index, count) => {
                let pos;
                switch(SETTINGS.placement) {
                    case "Random": {
                        const r = min_radius + Math.random() * (max_radius - min_radius);
                        const theta = Math.random() * 2 * Math.PI;
                        pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                        break;
                    }
                    case "Grid": {
                        const num_per_side = Math.ceil(Math.sqrt(count));
                        const spacing = (max_radius * 1.5) / num_per_side;
                        const grid_x = (index % num_per_side) - (num_per_side / 2) + 0.5;
                        const grid_y = Math.floor(index / num_per_side) - (num_per_side / 2) + 0.5;
                        pos = { x: grid_x * spacing, y: grid_y * spacing };
                        break;
                    }
                    case "Multi-Ring": {
                        const num_rings = 4;
                        const ring_index = index % num_rings;
                        const r = min_radius + (ring_index / (num_rings - 1)) * (max_radius - min_radius);
                        const objects_in_prev_rings = Math.floor(count/num_rings) * ring_index + Math.min(count % num_rings, ring_index);
                        const index_in_this_ring = index - objects_in_prev_rings;
                        const count_in_this_ring = Math.floor(count/num_rings) + (ring_index < (count % num_rings) ? 1 : 0);
                        const theta = 2 * Math.PI * (index_in_this_ring / (count_in_this_ring || 1));
                        pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                        break;
                    }
                    case "Circular":
                    default: {
                        const theta = 2 * Math.PI * index / count; 
                        const r = min_radius + (max_radius - min_radius) / 2;
                        pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                        break;
                    }
                }
                return { pos, vel: get_orbital_velocity(pos, central_body) };
            };

            if (SETTINGS.placement !== 'Empty') {
                for (let i = 0; i < SETTINGS.num_planets; i++) { const {pos, vel} = placementFunc(i, SETTINGS.num_planets); planets.push(new Planet(pos, vel)); }
                for (let i = 0; i < SETTINGS.num_gas_giants; i++) { const {pos, vel} = placementFunc(i, SETTINGS.num_gas_giants); gas_giants.push(new GasGiant(pos, vel)); }
                if (SETTINGS.enable_asteroids) {
                    for (let i = 0; i < SETTINGS.num_asteroids; i++) {
                        const {pos, vel} = placementFunc(i, SETTINGS.num_asteroids);
                        asteroids.push(new Asteroid(pos, vel));
                    }
                }
            }
        }

        generateStarfield();

        let max_object_dist = 0;
        [...bh_list, ...planets, ...gas_giants, ...asteroids, ...stars].forEach(obj => {
            max_object_dist = Math.max(max_object_dist, Math.hypot(obj.pos.x, obj.pos.y));
        });

        if (max_object_dist > 0) {
            const margin = 1.2;
            const required_zoom_x = (canvas.width * 0.8) / (max_object_dist * 2 * margin);
            const required_zoom_y = (canvas.height * 0.8) / (max_object_dist * 2 * margin);
            state.zoom = Math.min(required_zoom_x, required_zoom_y, 1.0);
        }

        // --- Special placement for Galactic Collision ---
        if (SETTINGS.galactic_collision_special) {
            // Place two supermassive black holes far apart with slow approach
            bh_list = [];
            const sep = 1800; // Large separation
            const masses = SETTINGS.bh_masses;
            const mass1 = (masses && masses.length > 0 ? masses[0] : 1500) * SOLAR_MASS_UNIT;
            const mass2 = (masses && masses.length > 1 ? masses[1] : 1500) * SOLAR_MASS_UNIT;
            bh_list.push(new BlackHole({x: -sep/2, y: 0}, mass1, {x: 0, y: 12}));
            bh_list.push(new BlackHole({x: sep/2, y: 0}, mass2, {x: 0, y: -12}));
        }

        // --- For large scenarios, increase min_radius for object placement ---
        let min_radius = (SETTINGS.num_black_holes > 0 || stars.length > 0) ? 100 : 50;
        let max_radius = { "Small": 200, "Medium": 300, "Large": 400, "Huge": 500 }[SETTINGS.sim_size] || 400;
        if (SETTINGS.num_planets + SETTINGS.num_gas_giants > 200) {
            min_radius = 600;
            max_radius = 2000;
        }

        // ...

        // Scenario info will be shown after splash screen completes
    };

    const updatePhysics = (dt) => {
        if(dt <= 0) return;
        state.frame_count++;
        
        // Performance optimization: skip physics updates for very large simulations
        const totalObjects = bh_list.length + planets.length + stars.length + gas_giants.length + asteroids.length;
        if (totalObjects > 1000 && state.frame_count % 2 === 0) {
            // Skip every other frame for very large simulations
            return;
        }
        
        // Determine gravity sources based on mutual gravity setting
        let major_sources = [...bh_list, ...stars, ...gas_giants];
        if (SETTINGS.mutual_gravity) {
            major_sources = [...bh_list, ...stars, ...gas_giants, ...planets, ...asteroids];
        }
        
        // Update physics for all objects
        const all_physics_objects = [...planets, ...asteroids, ...gas_giants, ...debris, ...stars];
        all_physics_objects.forEach(obj => {
            let effective_sources = major_sources;
            if (SETTINGS.mutual_gravity) {
                effective_sources = major_sources.filter(s => s.id !== obj.id);
            }
            obj.update_physics(dt, effective_sources);
            if (SETTINGS.show_trails) obj.update_trail();
        });

        // Update black hole orbits if enabled
        if (SETTINGS.bh_behavior === "Orbiting") {
            bh_list.forEach(bh => bh.update_orbit(dt, bh_list));
        }
        
        // Update black hole dynamic effects (accretion disk and jets)
        bh_list.forEach(bh => bh.update_dynamic_effects(dt));

        // Handle tidal disruption of stars by black holes
        const new_debris = [];
        stars.forEach(star => {
            if (star.alive && star.intact) {
                const { debris_count, fraction } = star.tidal_mass_loss(bh_list, dt);
                if (debris_count > 0) {
                    for (let i = 0; i < debris_count; i++) {
                        const eject_speed = (Math.random() * 9 + 1) * (1 + fraction);
                        const angle = Math.random() * 2 * Math.PI;
                        const dv = { x: eject_speed * Math.cos(angle), y: eject_speed * Math.sin(angle) };
                        const spawn_pos = { 
                            x: star.pos.x + Math.random()*4-2, 
                            y: star.pos.y + Math.random()*4-2 
                        };
                        new_debris.push(new Debris(spawn_pos, {
                            x: star.vel.x*0.1+dv.x, 
                            y: star.vel.y*0.1+dv.y
                        }));
                    }
                }
            }
        });
        debris.push(...new_debris);

        // Handle tidal disruption of planets by black holes
        planets.forEach(planet => {
            if (planet.alive && planet.intact) {
                const { debris_count, fraction } = planet.tidal_mass_loss(bh_list, dt);
                if (debris_count > 0) {
                    for (let i = 0; i < debris_count; i++) {
                        const eject_speed = (Math.random() * 6 + 2) * (1 + fraction);
                        const angle = Math.random() * 2 * Math.PI;
                        const dv = { x: eject_speed * Math.cos(angle), y: eject_speed * Math.sin(angle) };
                        const spawn_pos = { 
                            x: planet.pos.x + Math.random()*3-1.5, 
                            y: planet.pos.y + Math.random()*3-1.5 
                        };
                        new_debris.push(new Debris(spawn_pos, {
                            x: planet.vel.x*0.1+dv.x, 
                            y: planet.vel.y*0.1+dv.y
                        }));
                    }
                }
            }
        });
        debris.push(...new_debris);

        // Handle tidal disruption of gas giants by black holes
        gas_giants.forEach(gasGiant => {
            if (gasGiant.alive && gasGiant.intact) {
                const { debris_count, fraction } = gasGiant.tidal_mass_loss(bh_list, dt);
                if (debris_count > 0) {
                    for (let i = 0; i < debris_count; i++) {
                        const eject_speed = (Math.random() * 8 + 3) * (1 + fraction);
                        const angle = Math.random() * 2 * Math.PI;
                        const dv = { x: eject_speed * Math.cos(angle), y: eject_speed * Math.sin(angle) };
                        const spawn_pos = { 
                            x: gasGiant.pos.x + Math.random()*4-2, 
                            y: gasGiant.pos.y + Math.random()*4-2 
                        };
                        new_debris.push(new Debris(spawn_pos, {
                            x: gasGiant.vel.x*0.1+dv.x, 
                            y: gasGiant.vel.y*0.1+dv.y
                        }));
                    }
                }
            }
        });
        debris.push(...new_debris);

        // Handle star merging separately from other collisions
        if (SETTINGS.enable_star_merging) {
            handle_star_merging(stars);
        }
        
        // Handle collisions between stars and smaller objects (planets, gas giants, asteroids)
        handle_star_object_collisions();
        
        // Handle collisions for non-star objects
        handle_collisions([...planets, ...gas_giants, ...asteroids]);
        
        // Check for object absorption by black holes
        const check_and_absorb = (obj_list) => {
            return obj_list.filter(obj => {
                if(obj.alive && obj.check_absorption(bh_list)) {
                    // Find which black hole absorbed this object
                    let absorbing_bh = null;
                    for (const bh of bh_list) {
                        const dx = obj.pos.x - bh.pos.x;
                        const dy = obj.pos.y - bh.pos.y;
                        if (dx*dx + dy*dy < (bh.radius + ABSORB_BUFFER)**2) {
                            absorbing_bh = bh;
                            break;
                        }
                    }
                    
                    if (absorbing_bh) {
                        // Create subtle absorption particles (scaled back from explosion look)
                        let particle_count = 8; // Reduced from 15+
                        let particle_speed = 30; // Reduced speed
                        let particle_size = 3; // Smaller particles
                        let particle_color = '#c8c8c8';
                        
                        // Customize particles based on absorbed object type (but more subtle)
                        switch (obj.obj_type) {
                            case 'StarObject':
                                particle_count = 12;
                                particle_speed = 40;
                                particle_size = 4;
                                particle_color = obj.baseColor || SETTINGS.star_base_color || '#ffff00';
                                break;
                            case 'Planet':
                                particle_count = 10;
                                particle_speed = 35;
                                particle_size = 3;
                                particle_color = SETTINGS.planet_base_color || '#6495ed';
                                break;
                            case 'GasGiant':
                                particle_count = 15;
                                particle_speed = 45;
                                particle_size = 4;
                                particle_color = '#D2B48C';
                                break;
                            case 'Asteroid':
                                particle_count = 5;
                                particle_speed = 25;
                                particle_size = 2;
                                particle_color = '#8B4513';
                                break;
                            case 'Debris':
                                particle_count = 4;
                                particle_speed = 20;
                                particle_size = 2;
                                particle_color = '#c8c8c8';
                                break;
                        }
                        
                        // Create subtle absorption particles
                        for (let i = 0; i < particle_count; i++) {
                            const angle = Math.random() * 2 * Math.PI;
                            const speed = Math.random() * particle_speed + 15;
                            const p_vel = { 
                                x: speed * Math.cos(angle), 
                                y: speed * Math.sin(angle) 
                            };
                            
                            const lifetime = Math.random() * 0.6 + 0.3; // Shorter lifetime
                            const start_size = particle_size + Math.random() * 2;
                            const end_size = 1 + Math.random() * 1;
                            
                            const rgb = hexToRgb(particle_color);
                            if (rgb) {
                                // Add subtle color variation
                                const color_variation = 20; // Reduced variation
                                const r = Math.max(0, Math.min(255, rgb.r + (Math.random() - 0.5) * color_variation));
                                const g = Math.max(0, Math.min(255, rgb.g + (Math.random() - 0.5) * color_variation));
                                const b = Math.max(0, Math.min(255, rgb.b + (Math.random() - 0.5) * color_variation));
                                particles.push(new Particle(obj.pos, p_vel, lifetime, start_size, end_size, `rgb(${r},${g},${b})`));
                            } else {
                                particles.push(new Particle(obj.pos, p_vel, lifetime, start_size, end_size, particle_color));
                            }
                        }
                        
                        // Add just a few high-energy particles for subtle effect
                        for (let i = 0; i < 2; i++) { // Reduced from 5
                            const angle = Math.random() * 2 * Math.PI;
                            const speed = Math.random() * 60 + 40; // Reduced speed
                            const p_vel = { 
                                x: speed * Math.cos(angle), 
                                y: speed * Math.sin(angle) 
                            };
                            particles.push(new Particle(obj.pos, p_vel, Math.random() * 0.4 + 0.6, 6, 1, 'rgb(255, 255, 255)'));
                        }
                    }
                    return false;
                }
                return obj.alive;
            });
        };

        // Apply absorption checks to all object types
        planets = check_and_absorb(planets);
        stars = check_and_absorb(stars);
        gas_giants = check_and_absorb(gas_giants);
        asteroids = check_and_absorb(asteroids);
        debris = check_and_absorb(debris);
        
        // Update particles and remove dead ones
        particles = particles.filter(p => p.is_alive());
        particles.forEach(p => p.update(dt));
        
        // Update gravity ripples and remove dead ones
        gravity_ripples = gravity_ripples.filter(r => r.is_alive());
        gravity_ripples.forEach(r => r.update(dt));
        
        // Memory management: limit particle and effect counts
        if (particles.length > 500) {
            particles = particles.slice(-500); // Keep only the most recent 500 particles
        }
        if (gravity_ripples.length > 20) {
            gravity_ripples = gravity_ripples.slice(-20); // Keep only the most recent 20 ripples
        }

        // Handle black hole merging
        let merged_this_step = true;
        while (merged_this_step && bh_list.length > 1) {
            merged_this_step = false;
            for (let i = 0; i < bh_list.length; i++) {
                for (let j = i + 1; j < bh_list.length; j++) {
                    const bh1 = bh_list[i], bh2 = bh_list[j];
                    const dx = bh1.pos.x - bh2.pos.x;
                    const dy = bh1.pos.y - bh2.pos.y;
                    if (dx*dx + dy*dy < (bh1.radius + bh2.radius)**2) {
                        const m1 = bh1.mass, m2 = bh2.mass, new_mass = m1 + m2;
                        const new_pos = { 
                            x: (bh1.pos.x * m1 + bh2.pos.x * m2) / new_mass, 
                            y: (bh1.pos.y * m1 + bh2.pos.y * m2) / new_mass 
                        };
                        const new_vel = { 
                            x: (bh1.vel.x * m1 + bh2.vel.x * m2) / new_mass, 
                            y: (bh1.vel.y * m1 + bh2.vel.y * m2) / new_mass 
                        };
                        
                        // Create gravity ripple effect for the merger
                        const mass_factor = Math.sqrt(new_mass / (DEFAULT_SETTINGS.bh_mass * SOLAR_MASS_UNIT));
                        gravity_ripples.push(new GravityRipple(new_pos, mass_factor));
                        
                        // Remove old black holes and add merged one
                        bh_list.splice(j, 1);
                        bh_list.splice(i, 1);
                        bh_list.push(new BlackHole(new_pos, new_mass, new_vel));
                        merged_this_step = true;
                        break;
                    }
                }
                if (merged_this_step) break;
            }
        }
        
        // Remove objects that are too far offscreen
        planets = planets.filter(p => !is_offscreen(p.pos));
        stars = stars.filter(s => !is_offscreen(s.pos));
        gas_giants = gas_giants.filter(g => !is_offscreen(g.pos));
        asteroids = asteroids.filter(a => !is_offscreen(a.pos));
        debris = debris.filter(d => !is_offscreen(d.pos));

        // Handle camera following
        let target = null;
        if (SETTINGS.follow_mode !== "None") {
            const follow_map = { 
                "BlackHole": bh_list, 
                "Planet": planets, 
                "GasGiant": gas_giants, 
                "Star": stars 
            };
            const target_list = follow_map[SETTINGS.follow_mode];
            if (target_list && target_list.length > 0) {
                if (target_list.length > 1) {
                    // Follow center of mass for multiple objects
                    let totalMass = 0, com = {x:0, y:0};
                    target_list.forEach(obj => { 
                        com.x += obj.pos.x * obj.mass; 
                        com.y += obj.pos.y * obj.mass; 
                        totalMass += obj.mass; 
                    });
                    if (totalMass > 0) {
                        target = { pos: { x: com.x/totalMass, y: com.y/totalMass }};
                    }
                } else { 
                    target = target_list[0]; 
                }
            }
        }
        if (target) { 
            state.pan.x = -target.pos.x * state.zoom; 
            state.pan.y = target.pos.y * state.zoom; 
        }
    }

    const drawScene = () => {
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        ctx.translate(canvas.width / 2 + state.pan.x, canvas.height / 2 + state.pan.y);
        ctx.scale(state.zoom, -state.zoom);


        if (SETTINGS.show_trails) {
            [...planets, ...gas_giants, ...asteroids, ...stars].forEach(obj => {
                if (obj.alive && obj.trail.length > 1) {
                    const baseColor = obj.baseColor || SETTINGS[`${obj.obj_type.toLowerCase()}_base_color`] || '#6495ed';
                    const rgb = hexToRgb(baseColor);
                    
                    if (SETTINGS.trail_style === "Cloud") {
                        // Draw cloud-like trail with multiple passes
                        for (let pass = 0; pass < 3; pass++) {
                            const trailWidth = (2.5 - pass * 0.5) / state.zoom;
                            const maxAlpha = 0.6 - pass * 0.15;
                            
                            ctx.lineWidth = trailWidth;
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            
                            // Create gradient for the trail
                            const gradient = ctx.createLinearGradient(0, 0, 0, 0);
                            gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${maxAlpha})`);
                            gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                            
                            ctx.strokeStyle = gradient;
                            ctx.beginPath();
                            
                            // Draw trail with smooth curves and fade-out
                            const first_point = world_to_screen(obj.trail[0]);
                            ctx.moveTo(first_point.x, first_point.y);
                            
                            for (let i = 1; i < obj.trail.length; i++) {
                                const point = world_to_screen(obj.trail[i]);
                                const age_factor = 1 - (obj.trail[i].age / SETTINGS.trail_length);
                                const velocity_factor = Math.min(1, obj.trail[i].velocity / 50);
                                const alpha = age_factor * velocity_factor * maxAlpha;
                                
                                ctx.globalAlpha = alpha;
                                
                                // Use quadratic curves for smoother trails
                                if (i < obj.trail.length - 1) {
                                    const next_point = world_to_screen(obj.trail[i + 1]);
                                    const cp_x = (point.x + next_point.x) / 2;
                                    const cp_y = (point.y + next_point.y) / 2;
                                    ctx.quadraticCurveTo(point.x, point.y, cp_x, cp_y);
                                } else {
                                    ctx.lineTo(point.x, point.y);
                                }
                            }
                            ctx.stroke();
                        }
                        
                        // Draw bright core trail
                        ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.9)`;
                        ctx.lineWidth = 1.0 / state.zoom;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        
                        const first_point = world_to_screen(obj.trail[0]);
                        ctx.moveTo(first_point.x, first_point.y);
                        
                        for (let i = 1; i < obj.trail.length; i++) {
                            const point = world_to_screen(obj.trail[i]);
                            const age_factor = 1 - (obj.trail[i].age / SETTINGS.trail_length);
                            ctx.globalAlpha = age_factor * 0.9;
                            ctx.lineTo(point.x, point.y);
                        }
                        ctx.stroke();
                        
                    } else if (SETTINGS.trail_style === "Glow") {
                        // Draw glowing trail with radial gradients
                        for (let i = 0; i < obj.trail.length; i++) {
                            const point = world_to_screen(obj.trail[i]);
                            const age_factor = 1 - (obj.trail[i].age / SETTINGS.trail_length);
                            const velocity_factor = Math.min(1, obj.trail[i].velocity / 50);
                            const intensity = age_factor * velocity_factor;
                            
                            if (intensity > 0.05) {
                                const radius = (3 + intensity * 5) / state.zoom;
                                const gradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, radius);
                                gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${intensity * 0.8})`);
                                gradient.addColorStop(0.5, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${intensity * 0.3})`);
                                gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                                
                                ctx.fillStyle = gradient;
                                ctx.beginPath();
                                ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                        
                    } else { // Simple style
                        // Draw simple trail with fade-out
                        ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.8)`;
                        ctx.lineWidth = 1.5 / state.zoom;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        
                        const first_point = world_to_screen(obj.trail[0]);
                        ctx.moveTo(first_point.x, first_point.y);
                        
                        for (let i = 1; i < obj.trail.length; i++) {
                            const point = world_to_screen(obj.trail[i]);
                            const age_factor = 1 - (obj.trail[i].age / SETTINGS.trail_length);
                            ctx.globalAlpha = age_factor * 0.8;
                            ctx.lineTo(point.x, point.y);
                        }
                        ctx.stroke();
                    }
                }
            });
            ctx.globalAlpha = 1; 
        }

        [...debris, ...asteroids, ...planets, ...gas_giants, ...stars].forEach(obj => { if (obj.alive) obj.draw(ctx); });
        
        particles.forEach(p => p.draw(ctx));
        
        // Draw gravity ripples (behind black holes)
        gravity_ripples.forEach(r => r.draw(ctx));
        
        ctx.globalAlpha = 1;
        
        bh_list.forEach(bh => bh.draw(ctx));
        
        // Draw hover effect for clickable objects
        if (!state.inspector_open) {
            const worldPos = screen_to_world(state.mouse);
            const hoveredObject = findObjectAtPosition(worldPos);
            if (hoveredObject) {
                const world_pos = world_to_screen(hoveredObject.object.pos);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2 / state.zoom;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(world_pos.x, world_pos.y, hoveredObject.object.radius + 5 / state.zoom, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw tooltip
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                const tooltipX = state.mouse.x + 15;
                const tooltipY = state.mouse.y - 10;
                
                // Get object info for tooltip
                let tooltipText = '';
                switch (hoveredObject.type) {
                    case 'BlackHole':
                        const bhMass = (hoveredObject.object.mass / SOLAR_MASS_UNIT).toFixed(1);
                        tooltipText = `Black Hole (${bhMass} M☉) - Click to inspect`;
                        break;
                    case 'Star':
                        const starMass = (hoveredObject.object.massInSuns || hoveredObject.object.mass / SOLAR_MASS_UNIT).toFixed(2);
                        tooltipText = `Star (${starMass} M☉) - Click to inspect`;
                        break;
                    case 'Planet':
                        tooltipText = `Planet - Click to inspect`;
                        break;
                    case 'GasGiant':
                        const gasGiantMass = (hoveredObject.object.massInJupiters || hoveredObject.object.mass / 50.0).toFixed(2);
                        tooltipText = `Gas Giant (${gasGiantMass} M♃) - Click to inspect`;
                        break;
                    case 'Asteroid':
                        tooltipText = `Asteroid - Click to inspect`;
                        break;
                }
                
                // Draw tooltip background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(tooltipX - 5, tooltipY - 20, ctx.measureText(tooltipText).width + 10, 25);
                
                // Draw tooltip text
                ctx.fillStyle = 'white';
                ctx.font = '12px Poppins';
                ctx.fillText(tooltipText, tooltipX, tooltipY);
                ctx.restore();
            }
        }

        ctx.restore();
        
        if (state.adding_mass) {
            // Draw drag line
            ctx.strokeStyle = 'lime'; 
            ctx.lineWidth = 3; 
            ctx.lineCap = 'round';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(state.add_start_screen.x, state.add_start_screen.y);
            ctx.lineTo(state.mouse.x, state.mouse.y); 
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw start point
            ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(state.add_start_screen.x, state.add_start_screen.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw end point
            ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(state.mouse.x, state.mouse.y, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw velocity arrow
            const dx = state.mouse.x - state.add_start_screen.x;
            const dy = state.mouse.y - state.add_start_screen.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 20) {
                const angle = Math.atan2(dy, dx);
                const arrowLength = 20;
                const arrowAngle = Math.PI / 6;
                
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(state.mouse.x, state.mouse.y);
                ctx.lineTo(
                    state.mouse.x - arrowLength * Math.cos(angle - arrowAngle),
                    state.mouse.y - arrowLength * Math.sin(angle - arrowAngle)
                );
                ctx.moveTo(state.mouse.x, state.mouse.y);
                ctx.lineTo(
                    state.mouse.x - arrowLength * Math.cos(angle + arrowAngle),
                    state.mouse.y - arrowLength * Math.sin(angle + arrowAngle)
                );
                ctx.stroke();
            }
        }

        if (SETTINGS.show_dynamic_overlays) {
            const lines = [ `Planets: ${planets.length} | Gas Giants: ${gas_giants.length} | Asteroids: ${asteroids.length}`, `Stars: ${stars.length} | Black Holes: ${bh_list.length}`, `Particles: ${particles.length} | Debris: ${debris.length}`, `---`, `Zoom: ${state.zoom.toFixed(2)}x | Sim Speed: ${SETTINGS.sim_speed.toFixed(1)}x`, `Status: ${state.paused ? 'Paused (Space)' : 'Running'}`, `Click objects to inspect | ESC to close` ];
            overlayDiv.innerHTML = lines.join('<br>');
        } else {
            overlayDiv.innerHTML = '';
        }
    };
    
    const gameLoop = (timestamp) => {
        if (!state.last_time) state.last_time = timestamp; 
        const dt_seconds = (timestamp - state.last_time) / 1000.0;
        state.last_time = timestamp;
        const dt_sim = Math.min(dt_seconds, 0.05) * SETTINGS.sim_speed * 50 * DT;
        if (!state.paused) updatePhysics(dt_sim);
        drawScene();
        requestAnimationFrame(gameLoop);
    };

	function resizeCanvas(){
		const W = window.innerWidth;
		const H = window.innerHeight;
		canvas.width  = W;  canvas.height  = H;        // sim layer
		starfieldCanvas.width  = W; starfieldCanvas.height = H; // star layer
		generateStarfield();                           // redraw background
	}
	window.addEventListener('resize', resizeCanvas);


    canvas.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        const uiContainer = document.querySelector('.ui-container');
        if (e.clientX > uiContainer.getBoundingClientRect().left) return;
        
        // Check if clicking on an object for inspection
        const worldPos = screen_to_world({ x: e.clientX, y: e.clientY });
        const clickedObject = findObjectAtPosition(worldPos);
        
        if (clickedObject && !state.inspector_open) {
            showObjectInspector(clickedObject.object, clickedObject.type);
            return;
        }
        
        // Close inspector if clicking on empty space
        if (state.inspector_open && !clickedObject) {
            hideObjectInspector();
            return;
        }
        
        state.mouse.down = true;
        if (SETTINGS.interactive_add) {
            state.adding_mass = true;
            state.add_start_screen = { x: e.clientX, y: e.clientY };
            state.add_start_world = screen_to_world(state.add_start_screen);
        }
    });

    window.addEventListener('mousemove', (e) => {
        state.mouse.x = e.clientX; state.mouse.y = e.clientY;
        if (state.mouse.down && !state.adding_mass) { state.pan.x += e.movementX; state.pan.y += e.movementY; }
    });
    
    window.addEventListener('mouseup', (e) => {
        if (e.button !== 0) return;
        state.mouse.down = false;
        if (state.adding_mass) {
            state.adding_mass = false;
            const add_end_world = screen_to_world({ x: e.clientX, y: e.clientY });
            const vel = { x: (add_end_world.x - state.add_start_world.x) * 3, y: (add_end_world.y - state.add_start_world.y) * 3 };
            const type = SETTINGS.input_object_type; let new_obj;
            if (type === 'Planet') new_obj = new Planet(state.add_start_world, vel);
            else if (type === 'Star') new_obj = new StarObject(state.add_start_world, vel);
            else if (type === 'NeutronStar') new_obj = new NeutronStar(state.add_start_world, vel);
            else if (type === 'WhiteDwarf') new_obj = new WhiteDwarf(state.add_start_world, vel);
            else if (type === 'Asteroid') new_obj = new Asteroid(state.add_start_world, vel);
            else if (type === 'GasGiant') new_obj = new GasGiant(state.add_start_world, vel);
            else if (type === 'Comet') new_obj = new Comet(state.add_start_world, vel);
            if(new_obj instanceof Planet) planets.push(new_obj);
            if(new_obj instanceof StarObject) stars.push(new_obj);
            if(new_obj instanceof NeutronStar) stars.push(new_obj);
            if(new_obj instanceof WhiteDwarf) stars.push(new_obj);
            if(new_obj instanceof Asteroid) asteroids.push(new_obj);
            if(new_obj instanceof GasGiant) gas_giants.push(new_obj);
            if(new_obj instanceof Comet) asteroids.push(new_obj);
        }
    });

    // Touch event handlers for mobile
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            const uiContainer = document.querySelector('.ui-container');
            if (touch.clientX > uiContainer.getBoundingClientRect().left) return;
            
            // Check if tapping on an object for inspection
            const worldPos = screen_to_world({ x: touch.clientX, y: touch.clientY });
            const tappedObject = findObjectAtPosition(worldPos);
            
            if (tappedObject && !state.inspector_open) {
                showObjectInspector(tappedObject.object, tappedObject.type);
                return;
            }
            
            // Close inspector if tapping on empty space
            if (state.inspector_open && !tappedObject) {
                hideObjectInspector();
                return;
            }
            
            state.touch_active = true;
            state.touch_id = touch.identifier;
            state.mouse.x = touch.clientX;
            state.mouse.y = touch.clientY;
            
            if (SETTINGS.interactive_add) {
                state.adding_mass = true;
                state.add_start_screen = { x: touch.clientX, y: touch.clientY };
                state.add_start_world = screen_to_world(state.add_start_screen);
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (state.touch_active && e.touches.length === 1) {
            const touch = e.touches[0];
            if (touch.identifier === state.touch_id) {
                state.mouse.x = touch.clientX;
                state.mouse.y = touch.clientY;
                
                // Pan the view if not adding mass
                if (!state.adding_mass) {
                    // Store previous position for delta calculation
                    const prevX = state.mouse.x;
                    const prevY = state.mouse.y;
                    const deltaX = touch.clientX - prevX;
                    const deltaY = touch.clientY - prevY;
                    state.pan.x += deltaX;
                    state.pan.y += deltaY;
                }
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (state.touch_active && e.changedTouches.length === 1) {
            const touch = e.changedTouches[0];
            if (touch.identifier === state.touch_id) {
                state.touch_active = false;
                state.touch_id = null;
                
                if (state.adding_mass) {
                    state.adding_mass = false;
                    const add_end_world = screen_to_world({ x: touch.clientX, y: touch.clientY });
                    const vel = { x: (add_end_world.x - state.add_start_world.x) * 3, y: (add_end_world.y - state.add_start_world.y) * 3 };
                    const type = SETTINGS.input_object_type; let new_obj;
                    if (type === 'Planet') new_obj = new Planet(state.add_start_world, vel);
                    else if (type === 'Star') new_obj = new StarObject(state.add_start_world, vel);
                    else if (type === 'NeutronStar') new_obj = new NeutronStar(state.add_start_world, vel);
                    else if (type === 'WhiteDwarf') new_obj = new WhiteDwarf(state.add_start_world, vel);
                    else if (type === 'Asteroid') new_obj = new Asteroid(state.add_start_world, vel);
                    else if (type === 'GasGiant') new_obj = new GasGiant(state.add_start_world, vel);
                    else if (type === 'Comet') new_obj = new Comet(state.add_start_world, vel);
                    if(new_obj instanceof Planet) planets.push(new_obj);
                    if(new_obj instanceof StarObject) stars.push(new_obj);
                    if(new_obj instanceof NeutronStar) stars.push(new_obj);
                    if(new_obj instanceof WhiteDwarf) stars.push(new_obj);
                    if(new_obj instanceof Asteroid) asteroids.push(new_obj);
                    if(new_obj instanceof GasGiant) gas_giants.push(new_obj);
                    if(new_obj instanceof Comet) asteroids.push(new_obj);
                }
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        state.touch_active = false;
        state.touch_id = null;
        state.adding_mass = false;
    }, { passive: false });

	window.addEventListener('wheel', (e) => {
		if (e.target !== canvas) return;
		e.preventDefault(); 
        const zoomFactor = 1.1; const oldZoom = state.zoom;
        let newZoom = (e.deltaY < 0) ? oldZoom * zoomFactor : oldZoom / zoomFactor;
        newZoom = Math.max(0.01, Math.min(newZoom, 100));
        const worldPos = screen_to_world({x: e.clientX, y: e.clientY});
        state.zoom = newZoom;
        const newScreenPos = { x: worldPos.x * state.zoom + canvas.width / 2, y: -worldPos.y * state.zoom + canvas.height / 2 };
        state.pan.x -= (newScreenPos.x - e.clientX);
        state.pan.y -= (newScreenPos.y - e.clientY);
	}, { passive: false });

    // Pinch-to-zoom for mobile
    let initialDistance = 0;
    let initialZoom = 1.0;
    let initialPan = { x: 0, y: 0 };

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            initialZoom = state.zoom;
            initialPan = { ...state.pan };
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            
            if (initialDistance > 0) {
                const scale = currentDistance / initialDistance;
                const newZoom = Math.max(0.01, Math.min(100, initialZoom * scale));
                
                // Calculate center point for zoom
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                const worldPos = screen_to_world({ x: centerX, y: centerY });
                
                state.zoom = newZoom;
                const newScreenPos = { 
                    x: worldPos.x * state.zoom + canvas.width / 2, 
                    y: -worldPos.y * state.zoom + canvas.height / 2 
                };
                state.pan.x = initialPan.x - (newScreenPos.x - centerX);
                state.pan.y = initialPan.y - (newScreenPos.y - centerY);
            }
        }
    }, { passive: false });

    window.addEventListener('keydown', (e) => {
        const panSpeed = 40 / state.zoom;
        if (e.key === ' ') { state.paused = !state.paused; e.preventDefault(); } 
        else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') state.pan.x += panSpeed;
        else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') state.pan.x -= panSpeed;
        else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') state.pan.y += panSpeed;
        else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') state.pan.y -= panSpeed;
        else if (e.key.toLowerCase() === 'home') { state.zoom = 1.0; state.pan = {x: 0, y: 0}; }
        else if (e.key === '-' || e.key === '_') { 
            SETTINGS.sim_speed = Math.max(0.1, SETTINGS.sim_speed - 0.2);
            updateSpeedDisplay();
        }
        else if (e.key === '=' || e.key === '+') { 
            SETTINGS.sim_speed = Math.min(5.0, SETTINGS.sim_speed + 0.2);
            updateSpeedDisplay();
        }
        else if (e.key.toLowerCase() === 'p') {
            takeScreenshot();
        }
        else if (e.key === 'Escape') {
            if (state.inspector_open) {
                hideObjectInspector();
            }
        }
    });
    
    // --- Save/Load Logic ---
    const save_simulation_state = () => {
        try {
            const savedState = { settings: SETTINGS, view: { zoom: state.zoom, pan: state.pan }, objects: [ ...bh_list.map(o => o.get_state()), ...planets.map(o => o.get_state()), ...stars.map(o => o.get_state()), ...gas_giants.map(o => o.get_state()), ...asteroids.map(o => o.get_state()), ...debris.map(o => o.get_state()) ] };
            localStorage.setItem(SAVE_KEY, JSON.stringify(savedState));
            alert("Simulation state saved!");
        } catch (e) { console.error("Error saving state:", e); alert("Failed to save simulation state."); }
    };
    
    const load_simulation_state = () => {
        const scenarioInfoDiv = document.getElementById('scenarioInfoDisplay');
        scenarioInfoDiv.classList.remove('visible');

        const savedJSON = localStorage.getItem(SAVE_KEY);
        if (!savedJSON) { alert("No saved state found."); return; }
        try {
            const loadedState = JSON.parse(savedJSON);
            SETTINGS = loadedState.settings || { ...DEFAULT_SETTINGS };
            const view = loadedState.view || { zoom: 1.0, pan: {x:0, y:0} };
            state.zoom = view.zoom; state.pan = view.pan;
            bh_list = []; planets = []; stars = []; gas_giants = []; asteroids = []; debris = []; particles = [];
            PhysicsObject_id_counter = 0; let max_id = 0;
            loadedState.objects.forEach(obj_state => {
                const { type, pos, vel, mass } = obj_state; let new_obj = null;
                if (type === 'Planet') new_obj = new Planet(pos, vel);
                else if (type === 'GasGiant') new_obj = new GasGiant(pos, vel);
                else if (type === 'Asteroid') new_obj = new Asteroid(pos, vel);
                else if (type === 'StarObject') new_obj = new StarObject(pos, vel);
                else if (type === 'Debris') new_obj = new Debris(pos, vel);
                else if (type === 'BlackHole') new_obj = new BlackHole(pos, mass, vel);
                if (new_obj) {
                    new_obj.set_state(obj_state);
                    if (new_obj instanceof Planet) planets.push(new_obj);
                    else if (new_obj instanceof GasGiant) gas_giants.push(new_obj);
                    else if (new_obj instanceof Asteroid) asteroids.push(new_obj);
                    else if (new_obj instanceof StarObject) stars.push(new_obj);
                    else if (new_obj instanceof Debris) debris.push(new_obj);
                    else if (new_obj instanceof BlackHole) bh_list.push(new_obj);
                    max_id = Math.max(max_id, new_obj.id || 0);
                }
            });
            PhysicsObject_id_counter = max_id + 1;
            alert("Simulation state loaded!"); state.paused = false;
            updateSpeedDisplay();
        } catch (e) { console.error("Error loading state:", e); alert("Failed to load state."); }
    }
    

    // --- Settings Menu ---
    const setting_items = [
        {"label": "Preset Scenario", "key": "preset_scenario", "type": "option", "options": ["None", "Binary BH", "Triple BH System", "Supermassive BH", "Star Cluster", "Kuiper Belt", "Sagittarius A*", "Binary Star System", "Slingshot","Rogue Encounter","Galactic Collision","Micro BH Swarm","Exoplanet Lab", "Solar System Lite", "Double Pulsar", "Sag A* Neighborhood", "Galactic Bar", "Quasar Feast", "Trappist-1x", "Rogue Planet Cloud", "Dyson Swarm", "Wormhole Chase", "Ringworld Mayhem", "Neutron Star Binary", "White Dwarf Cluster", "Comet Storm", "Compact Object Dance"]},
        {"label": "--- Simulation ---", "type": "separator"},
        {"label": "Gravitational Constant", "key": "gravitational_constant", "type": "float", "min": 0.1, "max": 20.0, "step": 0.1},
        {"label": "Mutual Gravity (All)", "key": "mutual_gravity", "type": "bool"},
        {"label": "Simulation Speed", "key": "sim_speed", "type": "float", "min": 0.0, "max": 5.0, "step": 0.1},
        {"label": "Simulation Size", "key": "sim_size", "type": "option", "options": ["Small", "Medium", "Large", "Huge"]},
        {"label": "Placement", "key": "placement", "type": "option", "options": ["Circular", "Multi-Ring", "Random", "Grid", "Empty"]},
        {"label": "--- Black Holes ---", "type": "separator"},
        {"label": "Number of Black Holes", "key": "num_black_holes", "type": "int", "min": 0, "max": 10, "step": 1},
        {"label": "Default BH Mass (Msun)", "key": "bh_mass", "type": "float", "min": 0.1, "max": 1000, "step": 0.5},
        {"label": "Use Individual BH Masses", "key": "use_individual_bh_masses", "type": "bool"},
        {"label": "BH Behavior", "key": "bh_behavior", "type": "option", "options": ["Static", "Orbiting"]},
        {"label": "Orbit Decay Rate", "key": "orbit_decay_rate", "type": "float", "min": 0.0, "max": 0.1, "step": 0.001, "precision": 3},
        {"label": "--- Objects ---", "type": "separator"},
        {"label": "Number of Planets", "key": "num_planets", "type": "int", "min": 0, "max": 200, "step": 1},
        {"label": "Number of Gas Giants", "key": "num_gas_giants", "type": "int", "min": 0, "max": 50, "step": 1},
        {"label": "Enable Asteroids", "key": "enable_asteroids", "type": "bool"},
        {"label": "Number of Asteroids", "key": "num_asteroids", "type": "int", "min": 0, "max": 500, "step": 5},
        {"label": "Initial Velocity", "key": "init_velocity", "type": "float", "min": 0, "max": 100, "step": 1},
        {"label": "Velocity StdDev", "key": "velocity_stddev", "type": "float", "min": 0, "max": 50, "step": 1},
        {"label": "Input Object Type", "key": "input_object_type", "type": "option", "options": ["Planet", "Star", "NeutronStar", "WhiteDwarf", "Asteroid", "GasGiant", "Comet"]},
        {"label": "Enable Star Merging", "key": "enable_star_merging", "type": "bool"},
        {"label": "Max Star Mass Before BH (Msun)", "key": "max_star_mass_before_bh", "type": "float", "min": 5.0, "max": 50.0, "step": 0.5},
        {"label": "--- Visuals ---", "type": "separator"},
        {"label": "Show Trails", "key": "show_trails", "type": "bool"},
        {"label": "Trail Style", "key": "trail_style", "type": "option", "options": ["Cloud", "Simple", "Glow"]},
        {"label": "Trail Length", "key": "trail_length", "type": "int", "min": 5, "max": 300, "step": 5},
        {"label": "Show BH Glow", "key": "show_bh_glow", "type": "bool"},
        {"label": "Show Accretion Disk", "key": "show_accretion_disk", "type": "bool"},
        {"label": "Show BH Jets", "key": "show_bh_jets", "type": "bool"},
        {"label": "Improved Lensing", "key": "improved_lensing", "type": "bool"},
        {"label": "Lensing Strength", "key": "lensing_strength", "type": "float", "min": 1, "max": 1000, "step": 10},
        {"label": "Star Field Density", "key": "star_density", "type": "int", "min": 0, "max": 30000, "step": 100},
        {"label": "Ambient Lighting", "key": "show_ambient_lighting", "type": "bool"},
        {"label": "Dynamic Object Colors", "key": "dynamic_object_properties", "type": "bool"},
        {"label": "Planet Base Color", "key": "planet_base_color", "type": "color"},
        {"label": "Star Base Color", "key": "star_base_color", "type": "color"},
        {"label": "--- UI & Control ---", "type": "separator"},
        {"label": "Interactive Add", "key": "interactive_add", "type": "bool"},
        {"label": "Follow Mode", "key": "follow_mode", "type": "option", "options": ["None", "BlackHole", "Planet", "GasGiant", "Star"]},
        {"label": "Show Overlays", "key": "show_dynamic_overlays", "type": "bool"},
    ];

    const buildSettingsMenu = () => {
        settingsGrid.innerHTML = '';
        localSettings = JSON.parse(JSON.stringify(SETTINGS)); 
		/* ------ utility to show the chosen preset's description ------ */
		function updatePresetInfo(presetName){
			const box = document.getElementById("presetInfo");
			const info = SCENARIO_INFO[presetName];
			if(!info || presetName === "None"){ box.innerHTML=""; box.style.display = 'none'; return; }
            box.style.display = 'block';
			box.innerHTML = `<h4>${info.title}</h4>${info.summary}`;
		}

        setting_items.forEach(item => {
            if (item.type === 'separator') {
                const sepDiv = document.createElement('div');
                sepDiv.className = 'setting-separator';
                // No need to remove star color setting anymore since we added it back
                sepDiv.innerHTML = `<h3>${item.label}</h3><div class="line"></div>`;
                settingsGrid.appendChild(sepDiv);
                return;
            }

            const label = document.createElement('div'); label.className = 'setting-label'; label.textContent = item.label;
            const controlContainer = document.createElement('div'); controlContainer.className = 'setting-control';
            const value = localSettings[item.key];

            if (item.type === 'int' || item.type === 'float') {
                const slider = document.createElement('input'); slider.type = 'range'; slider.min = item.min; slider.max = item.max; slider.step = item.step; slider.value = value;
                const valueDisplay = document.createElement('span'); valueDisplay.className = 'value-display'; valueDisplay.textContent = Number(value).toFixed(item.precision || (item.type === 'float' ? 1 : 0));
                slider.oninput = () => {
                    const val = item.type === 'int' ? parseInt(slider.value) : parseFloat(slider.value);
                    localSettings[item.key] = val; valueDisplay.textContent = val.toFixed(item.precision || (item.type === 'float' ? 1 : 0));
                    if (item.key === 'num_black_holes' || item.key === 'use_individual_bh_masses') updateIndivBHMassButtonVisibility();
                };
                controlContainer.append(slider, valueDisplay);
            } else if (item.type === 'bool') {
                const button = document.createElement('button'); button.className = 'toggle-button'; button.textContent = value ? 'On' : 'Off';
                button.onclick = () => { localSettings[item.key] = !localSettings[item.key]; button.textContent = localSettings[item.key] ? 'On' : 'Off'; if (item.key === 'use_individual_bh_masses') updateIndivBHMassButtonVisibility(); };
                controlContainer.appendChild(button);
            } else if (item.type === 'option') {
                const select = document.createElement('select');
                item.options.forEach(opt => { const option = document.createElement('option'); option.value = option.textContent = opt; if (opt === value) option.selected = true; select.appendChild(option); });
                select.onchange = (e) => {
                    localSettings[item.key] = e.target.value;
                    if (item.key === 'preset_scenario') {
                        updatePresetInfo(e.target.value);
                        // Also update the main scenario info display
                        current_scenario_name = e.target.value;
                        show_scenario_info();
                    }
                };
				controlContainer.appendChild(select);
            } else if (item.type === 'color') {
                const colorInput = document.createElement('input'); colorInput.type = 'color'; colorInput.value = value;
                colorInput.oninput = () => { localSettings[item.key] = colorInput.value; };
                controlContainer.appendChild(colorInput);
            }

            settingsGrid.append(label, controlContainer);

            if (item.key === 'orbit_decay_rate') {
                const bhMassBtnContainer = document.createElement('div');
                bhMassBtnContainer.style.gridColumn = '1 / -1';
                bhMassBtnContainer.style.textAlign = 'center';
                bhMassBtnContainer.innerHTML = `<button id="indivBHMassBtn" class="ui-button" style="margin-top: 10px;">Set Individual BH Masses</button>`;
                settingsGrid.appendChild(bhMassBtnContainer);
                bhMassBtnContainer.firstElementChild.onclick = showIndivBHMassMenu;
            }
        });
        updateIndivBHMassButtonVisibility();
		updatePresetInfo(localSettings.preset_scenario);
    };
    
    const updateIndivBHMassButtonVisibility = () => {
        const btn = document.getElementById('indivBHMassBtn');
        if (btn) btn.style.display = localSettings.use_individual_bh_masses && localSettings.num_black_holes > 1 ? 'inline-block' : 'none';
    }
    
    const showIndivBHMassMenu = () => {
        const content = document.getElementById('bhMassesContent');
        content.innerHTML = '';
        const num_bh = localSettings.num_black_holes;
        if (!localSettings.bh_masses || localSettings.bh_masses.length !== num_bh) {
            localSettings.bh_masses = Array(num_bh).fill(localSettings.bh_mass);
        }

        for (let i = 0; i < num_bh; i++) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'bh-mass-item';

            const label = document.createElement('label');
            label.textContent = `Black Hole #${i + 1}:`;

            const controlDiv = document.createElement('div');
            controlDiv.className = 'bh-mass-control';

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = 0.1;
            slider.max = 1000;
            slider.step = 0.1;
            slider.value = localSettings.bh_masses[i];
            slider.dataset.index = i;

            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'value-display';
            valueDisplay.textContent = `${Number(slider.value).toFixed(1)} Msun`;

            slider.oninput = (e) => {
                const index = parseInt(e.target.dataset.index, 10);
                const val = parseFloat(e.target.value);
                localSettings.bh_masses[index] = val;
                valueDisplay.textContent = `${val.toFixed(1)} Msun`;
            };
            
            controlDiv.append(slider, valueDisplay);
            itemDiv.append(label, controlDiv);
            content.appendChild(itemDiv);
        }
        bhMassesModal.classList.remove('hidden');
    }
    
    document.getElementById('bhMassesDone').onclick = () => bhMassesModal.classList.add('hidden');
    document.getElementById('inspectorClose').onclick = hideObjectInspector;
    document.getElementById('settingsBtn').onclick = () => { buildSettingsMenu(); settingsPanel.classList.remove('hidden'); state.paused = true; };
    document.getElementById('refreshScenarioBtn').onclick = () => { initialize_simulation(); state.paused = false; show_scenario_info(); updateSpeedDisplay(); };
    document.getElementById('resetAllBtn').onclick = () => { SETTINGS = JSON.parse(JSON.stringify(DEFAULT_SETTINGS)); initialize_simulation(); state.paused = false; show_scenario_info(); updateSpeedDisplay(); };
    document.getElementById('saveBtn').onclick = save_simulation_state;
    document.getElementById('loadBtn').onclick = load_simulation_state;
    document.getElementById('settingsApply').onclick = () => { SETTINGS = JSON.parse(JSON.stringify(localSettings)); settingsPanel.classList.add('hidden'); initialize_simulation(); state.paused = false; show_scenario_info(); updateSpeedDisplay(); };
    document.getElementById('settingsReset').onclick = () => { localSettings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS)); buildSettingsMenu(); };
    document.getElementById('settingsCancel').onclick = () => { settingsPanel.classList.add('hidden'); state.paused = false; };

    // Speed control functionality
    const updateSpeedDisplay = () => {
        const speedDisplay = document.getElementById('speedDisplay');
        speedDisplay.textContent = `${SETTINGS.sim_speed.toFixed(1)}x`;
    };

    document.getElementById('slowDownBtn').onclick = () => {
        SETTINGS.sim_speed = Math.max(0.1, SETTINGS.sim_speed - 0.2);
        updateSpeedDisplay();
    };

    document.getElementById('speedUpBtn').onclick = () => {
        SETTINGS.sim_speed = Math.min(5.0, SETTINGS.sim_speed + 0.2);
        updateSpeedDisplay();
    };

    // Reset view functionality
    document.getElementById('resetViewBtn').onclick = () => {
        state.zoom = 1.0;
        state.pan = { x: 0.0, y: 0.0 };
    };

    // Screenshot functionality
    const takeScreenshot = () => {
        try {
            // Create a temporary canvas to combine both layers
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // Draw starfield background
            tempCtx.drawImage(starfieldCanvas, 0, 0);
            
            // Draw simulation layer
            tempCtx.drawImage(canvas, 0, 0);
            
            // Create download link
            const link = document.createElement('a');
            link.download = `gravitas-screenshot-${Date.now()}.png`;
            link.href = tempCanvas.toDataURL();
            link.click();
        } catch (error) {
            console.error('Screenshot failed:', error);
            alert('Screenshot failed. Please try again.');
        }
    };
    
    document.getElementById('screenshotBtn').onclick = takeScreenshot;
    
    // Object type cycling functionality
    const objectTypes = [
        { type: "Star", emoji: "⭐", label: "Add Stars" },
        { type: "Planet", emoji: "🪐", label: "Add Planets" },
        { type: "GasGiant", emoji: "🪐", label: "Add Gas Giants" },
        { type: "Asteroid", emoji: "☄️", label: "Add Asteroids" },
        { type: "Comet", emoji: "☄️", label: "Add Comets" },
        { type: "NeutronStar", emoji: "⚡", label: "Add Neutron Stars" },
        { type: "WhiteDwarf", emoji: "💎", label: "Add White Dwarfs" }
    ];
    
    let currentTypeIndex = 0;
    
    const updateObjectTypeButton = () => {
        const btn = document.getElementById('objectTypeBtn');
        const currentType = objectTypes[currentTypeIndex];
        btn.innerHTML = `${currentType.emoji} ${currentType.label}`;
        btn.title = `Click to change what type of object you insert (currently: ${currentType.type})`;
        SETTINGS.input_object_type = currentType.type;
    };
    
    document.getElementById('objectTypeBtn').onclick = () => {
        currentTypeIndex = (currentTypeIndex + 1) % objectTypes.length;
        updateObjectTypeButton();
    };
    
    // Initialize the button
    updateObjectTypeButton();
    
    // Color randomizer easter egg (triple-click settings button)
    let settingsClickCount = 0;
    let settingsClickTimer = null;
    document.getElementById('settingsBtn').addEventListener('click', () => {
        settingsClickCount++;
        if (settingsClickTimer) clearTimeout(settingsClickTimer);
        
        settingsClickTimer = setTimeout(() => {
            if (settingsClickCount >= 3) {
                // Randomize colors
                const randomColor = () => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                SETTINGS.planet_base_color = randomColor();
                SETTINGS.star_base_color = randomColor();
                alert('🎨 Colors randomized! Check the settings panel.');
            }
            settingsClickCount = 0;
        }, 500);
    });

    // Initialize speed display
    updateSpeedDisplay();

    // Show mobile instructions on first visit
    let lastTap = 0;
    canvas.addEventListener('touchend', (e) => {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        if (tapLength < 500 && tapLength > 0) {
            // Double tap detected - reset view
            state.zoom = 1.0;
            state.pan = { x: 0.0, y: 0.0 };
        }
        lastTap = currentTime;
    });

    // Show mobile instructions for first-time mobile users
    if ('ontouchstart' in window && window.innerWidth <= 768) {
        const mobileInstructions = document.getElementById('mobileInstructions');
        mobileInstructions.style.display = 'block';
        setTimeout(() => {
            mobileInstructions.style.display = 'none';
        }, 5000);
    }

    // Initialize with error handling
    try {
        resizeCanvas();
        initialize_simulation();
        requestAnimationFrame(gameLoop);
    } catch (error) {
        console.error('Initialization failed:', error);
        alert('Failed to initialize simulation. Please refresh the page.');
    }

    });
    </script>
</body>
</html>