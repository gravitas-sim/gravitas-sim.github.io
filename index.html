<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravitas - Web Black Hole Sandbox</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Roboto+Mono:wght@400;700&display=swap');

		/* ===== Splash screen ===== */
		#splash{
			position:fixed;
			inset:0;                    /* top:0; right:0; bottom:0; left:0 */
			display:flex;
			align-items:center;
			justify-content:center;
			background:var(--bg-color);
			z-index:3000;               /* above every UI element */
			opacity:0;
			animation:
				splashFadeIn   1.6s   ease-out   0s   forwards,
				splashFadeOut  1.2s   ease-in    2.3s forwards;
		}
		
		/* Hide UI elements during splash screen */
		.ui-container, #overlay, #scenarioInfoDisplay {
			opacity: 0;
			transition: opacity 1.0s ease-in;
		}
		
		/* Show UI elements after splash */
		.ui-container.showUI, #overlay.showUI, #scenarioInfoDisplay.showUI {
			opacity: 1;
		}
		#splash h1{
			margin:0;
			font-family:'Poppins',sans-serif;
			font-weight:600;
			font-size: clamp(4rem, 8vw, 8rem);
			letter-spacing:0.12em;
			color:var(--primary-color);
			text-shadow:0 0 25px var(--primary-color);
			opacity: 0;
			animation: logoFadeIn 1.0s ease-out 0.3s forwards;
		}
		
		@keyframes logoFadeIn {
			from { opacity: 0; transform: scale(0.9); }
			to { opacity: 1; transform: scale(1.0); }
		}

		/*  hidden until JS adds .showCanvas  */
		#simulationCanvas, #starfieldCanvas {
			opacity:0;              /* fully transparent       */
			visibility:hidden;      /* not rendered at all     */
			transition:opacity 1.2s ease-in;  /* fade-in only */
		}

		/*  added by JS after splash is gone  */
		#simulationCanvas.showCanvas, #starfieldCanvas.showCanvas {
			visibility:visible;     /* render now              */
			opacity:1;              /* and fade up to opaque   */
		}


		/* --- keyframes --- */
		@keyframes splashFadeIn  { 
			from { opacity: 0; } 
			to { opacity: 1; } 
		}
		@keyframes splashFadeOut { 
			from { opacity: 1; } 
			to { opacity: 0; } 
		}


        :root {
            --bg-color: #0d0d1a;
            --text-color: #e0e0e0;
            --primary-color: #00aaff;
            --secondary-color: #ffaa00;
            --panel-bg: rgba(20, 20, 40, 0.95);
            --button-bg: #333;
            --button-hover-bg: #555;
            --button-apply-bg: #28a745;
            --button-apply-hover-bg: #218838;
            --separator-color: #00aaff80;
        }

		/* === layered canvases === */
		.sim-canvas{
			position:fixed; inset:0;
			width:100%; height:100%;
			display:block;
		}
		#starfieldCanvas{ z-index:1; }   /* back-most */
		#simulationCanvas{ z-index:2; }  /* front */


        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
        }
        
        /* Ensure clean splash screen start */
        html, body {
            background-color: var(--bg-color);
        }

        #simulationCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #overlay {
            position: fixed;
            top: 15px;
            left: 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            color: #ccc;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            line-height: 1.5;
            z-index: 10;
        }

        #scenarioInfoDisplay {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            padding: 10px 20px;
            background: var(--panel-bg);
            border: 1px solid var(--separator-color);
            border-radius: 8px;
            text-align: center;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #scenarioInfoDisplay.visible {
            opacity: 1;
        }
        #scenarioInfoDisplay h4 {
            margin: 0 0 5px 0;
            font-size: 18px;
            color: var(--primary-color);
            font-weight: 600;
        }
        #scenarioInfoDisplay p {
            margin: 0;
            font-size: 14px;
            color: var(--text-color);
            line-height: 1.4;
        }


        .ui-container {
            position: fixed;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        /* Mobile-friendly UI adjustments */
        @media (max-width: 768px) {
            .ui-container {
                top: 10px;
                right: 10px;
                gap: 8px;
            }
            
            .ui-button {
                padding: 12px 16px;
                font-size: 16px;
                min-height: 44px; /* iOS minimum touch target */
            }
            
            .speed-controls {
                padding: 10px 14px;
            }
            
            .speed-btn {
                padding: 8px 14px;
                font-size: 14px;
                min-width: 70px;
            }
            
            #settingsPanel {
                width: 95%;
                max-width: none;
                height: 95vh;
                max-height: none;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
                gap: 15px 20px;
            }
            
                    .setting-label {
            justify-self: start;
            text-align: left;
        }
        
        #mobileInstructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(13, 13, 26, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 170, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            z-index: 2000;
            max-width: 300px;
            text-align: center;
        }
        
        .mobile-instructions-content h3 {
            margin: 0 0 15px 0;
            color: var(--primary-color);
            font-size: 18px;
        }
        
        .mobile-instructions-content p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        }

        .ui-button {
            padding: 8px 16px;
            background-color: var(--button-bg);
            color: var(--text-color);
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            transition: background-color 0.2s ease, transform 0.1s ease;
            text-align: center;
        }

        .ui-button:hover {
            background-color: var(--button-hover-bg);
        }
        .ui-button:active {
            transform: scale(0.98);
        }

        .speed-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(20, 20, 40, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(0, 170, 255, 0.3);
        }

        .speed-btn {
            padding: 6px 12px;
            font-size: 12px;
            min-width: 60px;
        }

        .speed-display {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-color);
            min-width: 50px;
            text-align: center;
            font-weight: bold;
        }

        #settingsPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            height: 90vh;
            max-height: 850px;
            background: rgba(13, 13, 26, 0.85);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(0, 170, 255, 0.2);
            border-radius: 20px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 0 1px rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #settingsPanel.hidden {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
            pointer-events: none;
            filter: blur(10px);
        }

        .settings-header {
            padding: 25px 30px;
            text-align: center;
            font-size: 28px;
            font-weight: 600;
            color: var(--primary-color);
            background: linear-gradient(135deg, rgba(0, 170, 255, 0.1), rgba(0, 170, 255, 0.05));
            border-bottom: 1px solid rgba(0, 170, 255, 0.2);
            border-radius: 20px 20px 0 0;
            text-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }

        .settings-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 25px 35px;
            background: rgba(0, 0, 0, 0.1);
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px 35px;
            align-items: center;
        }
        
        .setting-item, .setting-special-button {
            display: contents;
        }
        
        .setting-label {
            justify-self: end;
            text-align: right;
            font-size: 15px;
            color: rgba(224, 224, 224, 0.9);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .setting-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .setting-control input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: linear-gradient(90deg, rgba(0, 170, 255, 0.3), rgba(0, 170, 255, 0.1));
            border-radius: 10px;
            outline: none;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .setting-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, var(--primary-color), #0088cc);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 
                0 2px 8px rgba(0, 170, 255, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: all 0.2s ease;
        }
        .setting-control input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 
                0 4px 12px rgba(0, 170, 255, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }
        .setting-control .value-display {
            min-width: 60px;
            text-align: left;
            font-family: 'Roboto Mono', monospace;
            color: rgba(224, 224, 224, 0.9);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .setting-control select, .setting-control .toggle-button {
            width: 100%;
            padding: 10px 12px;
            background: rgba(34, 34, 34, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 170, 255, 0.3);
            color: var(--text-color);
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        .setting-control select:hover, .setting-control .toggle-button:hover {
            background: rgba(44, 44, 44, 0.9);
            border-color: rgba(0, 170, 255, 0.5);
            transform: translateY(-1px);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        .setting-control select:focus, .setting-control .toggle-button:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 
                0 0 0 3px rgba(0, 170, 255, 0.2),
                0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .setting-control input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 50px;
            height: 30px;
            background-color: transparent;
            border: 2px solid rgba(0, 170, 255, 0.3);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .setting-control input[type="color"]:hover {
            border-color: rgba(0, 170, 255, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .setting-control input[type="color"]::-webkit-color-swatch {
            border-radius: 6px;
            border: none;
        }

        .setting-separator {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
        }
        .setting-separator h3 {
            margin: 0;
            color: var(--secondary-color);
            font-size: 18px;
            white-space: nowrap;
            text-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
        }
        .setting-separator .line {
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--separator-color), transparent);
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }

        .settings-footer {
            padding: 25px 30px;
            display: flex;
            justify-content: center;
            gap: 15px;
            background: linear-gradient(135deg, rgba(0, 170, 255, 0.05), rgba(0, 170, 255, 0.1));
            border-top: 1px solid rgba(0, 170, 255, 0.2);
            border-radius: 0 0 20px 20px;
        }
        
        .footer-button {
            padding: 12px 28px;
            font-size: 16px;
            background: rgba(40, 40, 40, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 170, 255, 0.3);
            border-radius: 10px;
            transition: all 0.3s ease;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        .footer-button:hover {
            background: rgba(50, 50, 50, 0.9);
            border-color: rgba(0, 170, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        #settingsApply { 
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.8), rgba(40, 167, 69, 0.6));
            border-color: rgba(40, 167, 69, 0.4);
        }
        #settingsApply:hover { 
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.9), rgba(40, 167, 69, 0.7));
            border-color: rgba(40, 167, 69, 0.6);
        }

        #bhMassesModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 450px;
            background-color: var(--panel-bg);
            border: 1px solid var(--primary-color);
            border-radius: 10px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.7);
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        #bhMassesModal.hidden { display: none; }
        .bh-masses-header { text-align: center; padding: 15px; font-size: 20px; color: var(--primary-color); }
        .bh-masses-content { 
            padding: 20px 30px; 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            max-height: 50vh; 
            overflow-y: auto; 
        }
        .bh-mass-item { 
            display: grid;
            grid-template-columns: 1fr 2fr;
            align-items: center;
            gap: 15px;
        }
        .bh-mass-item label {
            justify-self: end;
            text-align: right;
        }
        .bh-mass-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .bh-mass-control input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: #444;
            border-radius: 5px;
            outline: none;
        }
        .bh-mass-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }
        .bh-mass-control .value-display {
            min-width: 60px;
            text-align: left;
            font-family: 'Roboto Mono', monospace;
        }
        .bh-masses-footer { padding: 15px; text-align: center; }

		/* --- Preset title / summary box --- */
		.preset-info{
			margin:18px 0 10px;
			padding:12px 16px;
			background:rgba(0,0,0,.25);
			border:1px solid var(--separator-color);
			border-radius:6px;
			font-size:14px;
			line-height:1.4;
		}
		.preset-info h4{
			margin:0 0 4px;
			font-size:17px;
			color:var(--primary-color);
		}

    </style>
</head>
<body>
    <canvas id="starfieldCanvas" class="sim-canvas"></canvas>
	<canvas id="simulationCanvas" class="sim-canvas"></canvas>

    <!-- ✨ Splash screen -->
	<div id="splash">
	  <h1>GRAVITAS</h1>
	</div>

    <div id="overlay"></div>
    <div id="scenarioInfoDisplay"></div>
    <div id="mobileInstructions" style="display: none;">
        <div class="mobile-instructions-content">
            <h3>Mobile Controls</h3>
            <p>• <strong>Single tap & drag:</strong> Add object with velocity</p>
            <p>• <strong>Drag without adding:</strong> Pan the view</p>
            <p>• <strong>Pinch:</strong> Zoom in/out</p>
            <p>• <strong>Double tap:</strong> Reset view</p>
        </div>
    </div>

    <div class="ui-container">
        <button id="settingsBtn" class="ui-button">Settings</button>
        <button id="refreshScenarioBtn" class="ui-button">Refresh Scenario</button>
        <button id="resetAllBtn" class="ui-button">Reset to Default</button>
        <button id="saveBtn" class="ui-button">Save State</button>
        <button id="loadBtn" class="ui-button">Load State</button>
        
        <div class="speed-controls">
            <button id="slowDownBtn" class="ui-button speed-btn">⏪ Slow</button>
            <span id="speedDisplay" class="speed-display">1.0x</span>
            <button id="speedUpBtn" class="ui-button speed-btn">Fast ⏩</button>
        </div>
        
        <button id="resetViewBtn" class="ui-button">Reset View</button>
    </div>

    <div id="settingsPanel" class="hidden">
        <div class="settings-header">Simulation Settings</div>
        <div class="settings-content">
        <div id="presetInfo" class="preset-info"></div>

            <div id="settingsGrid" class="settings-grid"></div>
        </div>
        <div class="settings-footer">
            <button id="settingsApply" class="ui-button footer-button">Apply & Restart</button>
            <button id="settingsReset" class="ui-button footer-button">Reset to Defaults</button>
            <button id="settingsCancel" class="ui-button footer-button">Cancel</button>
        </div>
    </div>

    <div id="bhMassesModal" class="hidden">
        <div class="bh-masses-header">Set Individual Black Hole Masses (M<sub>sun</sub>)</div>
        <div id="bhMassesContent" class="bh-masses-content"></div>
        <div class="bh-masses-footer">
            <button id="bhMassesDone" class="ui-button">Done</button>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {

    const canvas = document.getElementById('simulationCanvas');
	// ---------- star-field layer ----------
	const starfieldCanvas = document.getElementById('starfieldCanvas');
	const starCtx         = starfieldCanvas.getContext('2d');
	const star_field = [];

	const splash = document.getElementById('splash');

	/*  nothing to show at first ↓  */
	canvas.classList.remove('showCanvas');
    starfieldCanvas.classList.remove('showCanvas');

	splash.addEventListener('animationend', (e) => {
		if (e.animationName === 'splashFadeOut') {
			splash.remove();                 // splash done
			canvas.classList.add('showCanvas');  // NOW fade the sim in
            starfieldCanvas.classList.add('showCanvas');
            
            // Show UI elements after a short delay
            setTimeout(() => {
                document.querySelector('.ui-container').classList.add('showUI');
                document.getElementById('overlay').classList.add('showUI');
                document.getElementById('scenarioInfoDisplay').classList.add('showUI');
                
                // Show scenario info after UI elements are visible
                setTimeout(() => {
                    show_scenario_info();
                }, 500);
            }, 200);
		}
	});

    const createAmbientGradient = () => {
        const grad = starCtx.createLinearGradient(0, 0, 0, starfieldCanvas.height);
        grad.addColorStop(0, '#1a1a3a');
        grad.addColorStop(1, '#0a0a1a');
        return grad;
    }

	function generateStarfield(){
		star_field.length = 0;
		const num = SETTINGS.star_density;
		const W = starfieldCanvas.width  * 2;
		const H = starfieldCanvas.height * 2;
		for(let i=0;i<num;i++){
			star_field.push({
				x: Math.random()*W - W/2,
				y: Math.random()*H - H/2,
				b: Math.random()*0.7 + 0.3,
				s: Math.random()*1.5 + 0.5
			});
		}
		drawStarfield();
	}

	function drawStarfield(){
        starCtx.fillStyle = SETTINGS.show_ambient_lighting ? createAmbientGradient() : '#0d0d1a';
        starCtx.fillRect(0,0,starfieldCanvas.width,starfieldCanvas.height);

		star_field.forEach(st=>{
			starCtx.globalAlpha = st.b;
			starCtx.fillStyle   = '#fff';
			starCtx.fillRect(
				st.x + starfieldCanvas.width/2,
				st.y + starfieldCanvas.height/2,
				st.s, st.s
			);
		});
		starCtx.globalAlpha = 1;
	}


    const ctx = canvas.getContext('2d');
    const overlayDiv = document.getElementById('overlay');
    const settingsPanel = document.getElementById('settingsPanel');
    const settingsGrid = document.getElementById('settingsGrid');
    const bhMassesModal = document.getElementById('bhMassesModal');

    const DT = 0.1;
    const SOLAR_MASS_UNIT = 1000;
    const ABSORB_BUFFER = 6;
    const MIN_INTERACTION_DISTANCE = 5.0;
    const SAVE_KEY = "gravitas_simulation_save";
    const BH_RADIUS_BASE = 15;
    const PLANET_RADIUS = 5;
    const GAS_GIANT_RADIUS = 15;
    const ASTEROID_RADIUS = 2;
    const STAR_OBJ_RADIUS = 10;
    const DEBRIS_RADIUS = 2;
    const MAX_STAR_MASS_BEFORE_BH = 20.0; // Stars above this mass (in solar masses) become black holes

    const DEFAULT_SETTINGS = {
        preset_scenario: "Binary BH", 
        gravitational_constant: 2.0,  
        follow_mode: "BlackHole",       
        num_planets: 15, num_gas_giants: 2, init_velocity: 20, velocity_stddev: 5,
        bh_mass: 10, num_black_holes: 1, bh_behavior: "Static", use_individual_bh_masses: false,
        bh_masses: [], orbit_decay_rate: 0.005, placement: "Random", 
        mutual_gravity: false,
        show_trails: true,
        sim_speed: 1.0,
        show_velocity_vectors: false, interactive_add: true, trail_length: 40,
        trail_style: "Glow",
        sim_size: "Large", 
        star_density: 10000,
        input_object_type: "Star", show_bh_glow: true,
        show_accretion_disk: false, show_bh_jets: false, improved_lensing: true, lensing_strength: 100,
        show_dynamic_overlays: true, enable_asteroids: true, num_asteroids: 10,
        dynamic_object_properties: true, record_simulation: false, 
        show_ambient_lighting: true,
        planet_base_color: "#6495ed", 
        star_base_color: "#ffff00",
        enable_star_merging: true,
        max_star_mass_before_bh: 20.0,  
    };
    let SETTINGS = { ...DEFAULT_SETTINGS };
    let localSettings = {};

    let state = {
        zoom: 1.0, pan: { x: 0.0, y: 0.0 }, paused: false, frame_count: 0,
        mouse: { x: 0, y: 0, down: false }, adding_mass: false,
        add_start_screen: { x: 0, y: 0 }, add_start_world: { x: 0, y: 0 },
        touch_active: false, touch_id: null,
        last_time: 0,
    };

    let bh_list = [], planets = [], stars = [], gas_giants = [], asteroids = [],
        debris = [], particles = [], gwaves = [], gravity_ripples = [];
    
    let PhysicsObject_id_counter = 0;



    const world_to_screen = (pos) => ({ x: pos.x, y: pos.y });

    const screen_to_world = (spos) => ({
        x: (spos.x - canvas.width / 2 - state.pan.x) / state.zoom,
        y: -(spos.y - canvas.height / 2 - state.pan.y) / state.zoom
    });

    const is_offscreen = (pos, buffer_factor = 1.5) => {
        const half_width_world = (canvas.width / (2 * state.zoom)) * buffer_factor;
        const half_height_world = (canvas.height / (2 * state.zoom)) * buffer_factor;
        const world_center_x = -state.pan.x / state.zoom;
        const world_center_y = state.pan.y / state.zoom;
        return (pos.x < world_center_x - half_width_world ||
                pos.x > world_center_x + half_width_world ||
                pos.y < world_center_y - half_height_world ||
                pos.y > world_center_y + half_height_world);
    }
    
    const hexToRgb = (hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
    }

    const compute_dynamic_color = (base_color_hex, pos, bh_list, threshold = 300.0, target_color = {r:255, g:0, b:0}) => {
        if (!bh_list || bh_list.length === 0 || !SETTINGS.dynamic_object_properties) return base_color_hex;
        let min_dist_sq = Infinity;
        for (const bh of bh_list) {
            const dx = pos.x - bh.pos.x;
            const dy = pos.y - bh.pos.y;
            min_dist_sq = Math.min(min_dist_sq, dx*dx + dy*dy);
        }
        const f = Math.max(0.0, Math.min(1.0, (threshold - Math.sqrt(min_dist_sq)) / threshold));
        const base_color = hexToRgb(base_color_hex);
        if (!base_color) return base_color_hex;
        const r = Math.round(base_color.r * (1 - f) + target_color.r * f);
        const g = Math.round(base_color.g * (1 - f) + target_color.g * f);
        const b = Math.round(base_color.b * (1 - f) + target_color.b * f);
        return `rgb(${r},${g},${b})`;
    }

    const gravitational_acceleration = (target_pos, sources) => {
        let ax = 0.0, ay = 0.0;
        const G_val = SETTINGS.gravitational_constant;
        for (const s of sources) {
            const dx = s.pos.x - target_pos.x;
            const dy = s.pos.y - target_pos.y;
            let r_sq = dx*dx + dy*dy;
            if (r_sq < MIN_INTERACTION_DISTANCE**2) r_sq = MIN_INTERACTION_DISTANCE**2;
            const r = Math.sqrt(r_sq);
            if (r === 0) continue;
            const a_mag = G_val * s.mass / r_sq;
            ax += a_mag * (dx / r);
            ay += a_mag * (dy / r);
        }
        return { ax, ay };
    };

    class PhysicsObject {
        constructor(pos, vel, mass, radius, obj_type = "object") {
            this.id = PhysicsObject_id_counter++;
            this.pos = { ...pos };
            this.vel = { ...vel };
            this.mass = parseFloat(mass);
            this.radius = parseFloat(radius);
            this.obj_type = obj_type;
            this.trail = [];
            this.alive = true;
        }

        update_physics(dt, gravity_sources) {
            if (!this.alive) return;
            const { ax, ay } = gravitational_acceleration(this.pos, gravity_sources);
            this.vel.x += ax * dt;
            this.vel.y += ay * dt;
            this.pos.x += this.vel.x * dt;
            this.pos.y += this.vel.y * dt;
        }

        update_trail() {
            if (!this.alive) return;
            // Add position with timestamp and velocity for better trail effects
            this.trail.push({ 
                ...this.pos, 
                timestamp: Date.now(),
                velocity: Math.hypot(this.vel.x, this.vel.y),
                age: 0
            });
            if (this.trail.length > SETTINGS.trail_length) this.trail.shift();
            
            // Update age of all trail points
            this.trail.forEach(point => point.age += 1);
        }

        check_absorption(bh_list) {
            if (!this.alive) return false;
            for (const bh of bh_list) {
                const dx = this.pos.x - bh.pos.x;
                const dy = this.pos.y - bh.pos.y;
                if (dx*dx + dy*dy < (bh.radius + ABSORB_BUFFER)**2) {
                    this.alive = false;
                    bh.mass += this.mass || 0;
                    bh.updateRadius();
                    return true;
                }
            }
            return false;
        }

        get_state() { return { id: this.id, type: this.obj_type, pos: this.pos, vel: this.vel, mass: this.mass, radius: this.radius, alive: this.alive }; }
        set_state(s) { Object.assign(this, s); this.trail = []; }
        draw(ctx) {}
    }

    class Planet extends PhysicsObject {
        constructor(pos, vel) { super(pos, vel, 1.0, PLANET_RADIUS, "Planet"); }
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            ctx.fillStyle = compute_dynamic_color(SETTINGS.planet_base_color, this.pos, bh_list);
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();
        }
    }
    
    class GasGiant extends PhysicsObject {
        constructor(pos, vel) { super(pos, vel, 50.0, GAS_GIANT_RADIUS, "GasGiant"); }
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            ctx.fillStyle = '#D2B48C';
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();
            if (this.radius * state.zoom > 4) {
                ctx.fillStyle = '#A0522D';
                const band_height = Math.max(1 / state.zoom, this.radius * 0.3);
                ctx.fillRect(world_pos.x - this.radius, world_pos.y - this.radius / 3 - band_height / 2, this.radius * 2, band_height);
                ctx.fillRect(world_pos.x - this.radius, world_pos.y + this.radius / 3 - band_height / 2, this.radius * 2, band_height);
            }
        }
    }
    
    class Asteroid extends PhysicsObject {
        constructor(pos, vel) { super(pos, vel, 0.1, ASTEROID_RADIUS, "Asteroid"); }
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    const getStarColor = (massInSuns) => {
        const lowMassColor = { r: 255, g: 180, b: 100 }; // Reddish-Orange for ~0.2 Msun
        const sunColor = { r: 255, g: 255, b: 240 };     // Creamy White for 1.0 Msun
        const highMassColor = { r: 170, g: 200, b: 255 };// Bluish-White for ~3.0+ Msun

        const lerp = (a, b, t) => a + (b - a) * Math.max(0, Math.min(1, t));

        let r, g, b;
        if (massInSuns <= 1.0) {
            const t = (massInSuns - 0.2) / (1.0 - 0.2);
            r = lerp(lowMassColor.r, sunColor.r, t);
            g = lerp(lowMassColor.g, sunColor.g, t);
            b = lerp(lowMassColor.b, sunColor.b, t);
        } else {
            const t = (massInSuns - 1.0) / (3.0 - 1.0);
            r = lerp(sunColor.r, highMassColor.r, t);
            g = lerp(sunColor.g, highMassColor.g, t);
            b = lerp(sunColor.b, highMassColor.b, t);
        }
        return `#${Math.round(r).toString(16).padStart(2, '0')}${Math.round(g).toString(16).padStart(2, '0')}${Math.round(b).toString(16).padStart(2, '0')}`;
    };

    class StarObject extends PhysicsObject {
        constructor(pos, vel, massInSuns = null) {
            let finalMassInSuns;
            if (massInSuns !== null) {
                finalMassInSuns = massInSuns;
            } else {
                // Skewed distribution to favor smaller, more common stars. Range ~0.2 to 3.2 Msun.
                finalMassInSuns = Math.pow(10, (Math.random() * 1.5) - 0.7); 
            }
            
            const radius = STAR_OBJ_RADIUS * Math.pow(finalMassInSuns, 0.75); // Mass-radius relation R ~ M^0.75
            
            super(pos, vel, finalMassInSuns * SOLAR_MASS_UNIT, radius, "StarObject");
            this.massInSuns = finalMassInSuns;
            this.baseColor = getStarColor(this.massInSuns);
            this.intact = true;
        }
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            ctx.fillStyle = compute_dynamic_color(this.baseColor, this.pos, bh_list, 400.0, {r:255, g:50, b:0});
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();

            // Draw mass label, adapted from BlackHole.draw
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            const true_screen_pos = {
                x: world_pos.x * state.zoom + canvas.width / 2 + state.pan.x,
                y: -world_pos.y * state.zoom + canvas.height / 2 + state.pan.y
            };
            const screen_radius = this.radius * state.zoom;
            
            if (screen_radius > 5) { // Only draw label if star is big enough on screen
                const label_y_offset = screen_radius + 12;
                ctx.font = '12px Roboto Mono';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 4;
                ctx.fillText(`${this.massInSuns.toFixed(2)} Msun`, true_screen_pos.x, true_screen_pos.y + label_y_offset);
            }
            ctx.restore();
        }
        tidal_mass_loss(bh_list, dt) {
            if (!this.intact || !bh_list || bh_list.length === 0) return { debris_count: 0, fraction: 0 };
            let min_dist_sq = Infinity, closest_bh = null;
            for (const bh of bh_list) {
                const dx = this.pos.x - bh.pos.x;
                const dy = this.pos.y - bh.pos.y;
                const dist_sq = dx*dx + dy*dy;
                if (dist_sq < min_dist_sq) {
                    min_dist_sq = dist_sq;
                    closest_bh = bh;
                }
            }
            if (!closest_bh) return { debris_count: 0, fraction: 0 };
            const tidal_threshold_sq = (closest_bh.radius * 5)**2;
            if (min_dist_sq < tidal_threshold_sq) {
                const min_dist = Math.sqrt(min_dist_sq);
                const tidal_threshold = Math.sqrt(tidal_threshold_sq);
                const fraction = Math.max(0.0, (tidal_threshold - min_dist) / tidal_threshold);
                this.mass -= this.mass * fraction * 0.1 * dt;
                let debris_count = Math.floor(fraction * 50 * dt);
                if (this.mass <= 1.0) {
                    this.intact = false;
                    this.alive = false;
                    debris_count += 30;
                }
                return { debris_count, fraction };
            }
            return { debris_count: 0, fraction: 0 };
        }
        get_state() { 
            const baseState = super.get_state();
            return { ...baseState, massInSuns: this.massInSuns, baseColor: this.baseColor };
        }
        set_state(s) {
            super.set_state(s);
            this.massInSuns = s.massInSuns;
            this.baseColor = s.baseColor;
        }
    }
    
    class Debris extends PhysicsObject {
        constructor(pos, vel) { super(pos, vel, 0.01, DEBRIS_RADIUS, "Debris"); }
        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            ctx.fillStyle = compute_dynamic_color('#c8c8c8', this.pos, bh_list, 200.0, {r:255, g:100, b:0});
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    class BlackHole {
        constructor(pos, mass, vel = {x: 0, y: 0}) {
            this.pos = { ...pos };
            this.mass = parseFloat(mass);
            this.vel = { ...vel };
            this.obj_type = "BlackHole";
            this.updateRadius();
        }

        updateRadius() {
            const mass_scale = Math.max(0.1, this.mass / (DEFAULT_SETTINGS.bh_mass * SOLAR_MASS_UNIT));
            this.radius = BH_RADIUS_BASE * Math.pow(mass_scale, 0.5);
        }
        
        update_orbit(dt, other_bhs) {
            if (SETTINGS.bh_behavior !== "Orbiting" || other_bhs.length <= 1) return;
            const { ax, ay } = gravitational_acceleration(this.pos, other_bhs.filter(bh => bh !== this));
            this.vel.x += ax * dt; this.vel.y += ay * dt;
            const decay_factor = 1.0 - (SETTINGS.orbit_decay_rate * dt);
            this.vel.x *= decay_factor; this.vel.y *= decay_factor;
            this.pos.x += this.vel.x * dt; this.pos.y += this.vel.y * dt;
        }

        draw(ctx) {
            const world_pos = world_to_screen(this.pos);
            const world_radius = this.radius;

            if (SETTINGS.show_accretion_disk) {
                const disk_radius = world_radius * 2.5;
                if (disk_radius > world_radius) {
                    const grad = ctx.createRadialGradient(world_pos.x, world_pos.y, world_radius * 1.1, world_pos.x, world_pos.y, disk_radius);
                    grad.addColorStop(0, 'rgba(255, 190, 0, 0)');
                    grad.addColorStop(0.5, 'rgba(255, 165, 0, 0.7)');
                    grad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(world_pos.x, world_pos.y, disk_radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            if (SETTINGS.show_bh_glow) {
                const glow_radius = world_radius * 1.8;
                const grad = ctx.createRadialGradient(world_pos.x, world_pos.y, world_radius, world_pos.x, world_pos.y, glow_radius);
                grad.addColorStop(0, 'rgba(200, 200, 255, 0.4)');
                grad.addColorStop(1, 'rgba(200, 200, 255, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(world_pos.x, world_pos.y, glow_radius, 0, 2 * Math.PI);
                ctx.fill();
            }

            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, world_radius, 0, 2 * Math.PI);
            ctx.fill();

            if (SETTINGS.show_bh_jets) {
                const jet_length = world_radius * 5;
                const jet_width = Math.max(1 / state.zoom, world_radius * 0.2);
                ctx.fillStyle = 'rgba(255, 140, 0, 0.8)';
                ctx.fillRect(world_pos.x - jet_width / 2, world_pos.y + world_radius, jet_width, jet_length);
                ctx.fillRect(world_pos.x - jet_width / 2, world_pos.y - world_radius, jet_width, -jet_length);
            }
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            const true_screen_pos = {
                x: world_pos.x * state.zoom + canvas.width / 2 + state.pan.x,
                y: -world_pos.y * state.zoom + canvas.height / 2 + state.pan.y
            };

            const screen_radius = world_radius * state.zoom;
            let label_y_offset = screen_radius + 15;
            if (SETTINGS.show_bh_jets) label_y_offset = (screen_radius * 5) + screen_radius + 10;
            else if (SETTINGS.show_accretion_disk) label_y_offset = (screen_radius * 2.5) + 10;
            else if (SETTINGS.show_bh_glow) label_y_offset = (screen_radius * 1.8) + 10;

            ctx.font = '14px Roboto Mono';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 4;
            ctx.fillText(`${(this.mass / SOLAR_MASS_UNIT).toFixed(1)} Msun`, true_screen_pos.x, true_screen_pos.y + label_y_offset);
            
            ctx.restore();
        }
        
        get_state() { return { type: this.obj_type, pos: this.pos, vel: this.vel, mass: this.mass }; }
        set_state(s) { this.pos = s.pos; this.vel = s.vel; this.mass = s.mass; this.updateRadius(); }
    }
    
    class Particle {
        constructor(pos, vel, lifetime = 0.8, start_size = 5, end_size = 1, color = 'rgb(255,255,100)') {
            this.pos = { ...pos }; this.vel = { ...vel }; this.lifetime = Math.max(0.1, lifetime);
            this.age = 0; this.start_size = start_size; this.end_size = end_size;
            this.color = color;
        }
        update(dt) {
            this.pos.x += this.vel.x * dt; this.pos.y += this.vel.y * dt; this.age += dt;
        }
        is_alive() { return this.age < this.lifetime; }
        draw(ctx) {
            const life_fraction = this.age / this.lifetime;
            const current_size = this.start_size * (1 - life_fraction) + this.end_size * life_fraction;
            const alpha = 1 - life_fraction;
            if (current_size < 1 || alpha < 0.05) return;
            const world_pos = world_to_screen(this.pos);
            ctx.fillStyle = this.color;
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(world_pos.x, world_pos.y, current_size / state.zoom, 0, 2 * Math.PI);
            ctx.fill();
        }
    }
    
    class GravityRipple {
        constructor(pos, mass_factor = 1.0) {
            this.pos = { ...pos };
            this.age = 0;
            this.lifetime = 3.0; // 3 seconds as requested
            this.max_radius = 200 * mass_factor; // Scale with mass
            this.start_radius = 10;
            this.pulse_count = 0;
            this.max_pulses = 5;
            this.pulse_interval = this.lifetime / this.max_pulses;
        }
        
        update(dt) {
            this.age += dt;
            this.pulse_count = Math.floor(this.age / this.pulse_interval);
        }
        
        is_alive() { 
            return this.age < this.lifetime; 
        }
        
        draw(ctx) {
            if (this.age >= this.lifetime) return;
            
            const world_pos = world_to_screen(this.pos);
            const life_fraction = this.age / this.lifetime;
            const base_alpha = 1 - life_fraction;
            
            // Draw multiple expanding rings
            for (let i = 0; i <= this.pulse_count && i < this.max_pulses; i++) {
                const pulse_age = this.age - (i * this.pulse_interval);
                const pulse_fraction = pulse_age / this.pulse_interval;
                
                if (pulse_fraction >= 0 && pulse_fraction <= 1) {
                    const current_radius = this.start_radius + (this.max_radius - this.start_radius) * pulse_fraction;
                    const pulse_alpha = base_alpha * (1 - pulse_fraction) * 0.6;
                    
                    if (pulse_alpha > 0.01) {
                        // Create radial gradient for the ripple
                        const gradient = ctx.createRadialGradient(
                            world_pos.x, world_pos.y, 0,
                            world_pos.x, world_pos.y, current_radius / state.zoom
                        );
                        
                        // Use gravitational wave colors (cyan/blue)
                        gradient.addColorStop(0, `rgba(0, 255, 255, ${pulse_alpha * 0.8})`);
                        gradient.addColorStop(0.3, `rgba(0, 200, 255, ${pulse_alpha * 0.6})`);
                        gradient.addColorStop(0.7, `rgba(0, 150, 255, ${pulse_alpha * 0.3})`);
                        gradient.addColorStop(1, `rgba(0, 100, 255, 0)`);
                        
                        ctx.fillStyle = gradient;
                        ctx.globalAlpha = 1;
                        ctx.beginPath();
                        ctx.arc(world_pos.x, world_pos.y, current_radius / state.zoom, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Add a subtle ring outline
                        ctx.strokeStyle = `rgba(0, 255, 255, ${pulse_alpha * 0.4})`;
                        ctx.lineWidth = 2 / state.zoom;
                        ctx.beginPath();
                        ctx.arc(world_pos.x, world_pos.y, current_radius / state.zoom, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                }
            }
        }
    }
    
    const handle_star_merging = (stars_list) => {
        let merged_this_step = true;
        let merge_count = 0;
        const max_merges_per_step = 3; // Prevent infinite loops
        
        while (merged_this_step && stars_list.length > 1 && merge_count < max_merges_per_step) {
            merged_this_step = false;
            for (let i = 0; i < stars_list.length; i++) {
                for (let j = i + 1; j < stars_list.length; j++) {
                    const star1 = stars_list[i], star2 = stars_list[j];
                    if (!star1.alive || !star2.alive) continue;
                    
                    const dx = star2.pos.x - star1.pos.x;
                    const dy = star2.pos.y - star1.pos.y;
                    const dist_sq = dx*dx + dy*dy;
                    const min_dist = star1.radius + star2.radius;
                    
                    if (dist_sq < min_dist**2 && dist_sq > 1e-6) {
                        // Calculate merged star properties
                        const m1 = star1.mass, m2 = star2.mass;
                        const total_mass = m1 + m2;
                        const new_mass_in_suns = total_mass / SOLAR_MASS_UNIT;
                        
                        // Center of mass position and velocity
                        const new_pos = { 
                            x: (star1.pos.x * m1 + star2.pos.x * m2) / total_mass, 
                            y: (star1.pos.y * m1 + star2.pos.y * m2) / total_mass 
                        };
                        const new_vel = { 
                            x: (star1.vel.x * m1 + star2.vel.x * m2) / total_mass, 
                            y: (star1.vel.y * m1 + star2.vel.y * m2) / total_mass 
                        };
                        
                        // Create explosion particles for the merger
                        for (let k = 0; k < 25; k++) {
                            const angle = Math.random() * 2 * Math.PI;
                            const speed = Math.random() * 80 + 40;
                            const p_vel = { 
                                x: speed * Math.cos(angle), 
                                y: speed * Math.sin(angle) 
                            };
                            const rgb = hexToRgb(star1.baseColor);
                            if (rgb) {
                                particles.push(new Particle(new_pos, p_vel, Math.random()*0.8+0.6, 8, 2, `rgb(${rgb.r},${rgb.g},${rgb.b})`));
                            } else {
                                particles.push(new Particle(new_pos, p_vel, Math.random()*0.8+0.6, 8, 2, 'rgb(255, 255, 100)'));
                            }
                        }
                        
                        // Create some debris from the merger
                        for (let k = 0; k < 8; k++) {
                            const angle = Math.random() * 2 * Math.PI;
                            const speed = Math.random() * 30 + 10;
                            const debris_vel = { 
                                x: speed * Math.cos(angle), 
                                y: speed * Math.sin(angle) 
                            };
                            const debris_pos = { 
                                x: new_pos.x + (Math.random() - 0.5) * 10, 
                                y: new_pos.y + (Math.random() - 0.5) * 10 
                            };
                            debris.push(new Debris(debris_pos, {x: new_vel.x + debris_vel.x, y: new_vel.y + debris_vel.y}));
                        }
                        
                        // Remove the original stars
                        star1.alive = false;
                        star2.alive = false;
                        stars_list.splice(j, 1);
                        stars_list.splice(i, 1);
                        
                        // Check if the merged star should become a black hole
                        if (new_mass_in_suns >= SETTINGS.max_star_mass_before_bh) {
                            // Create a black hole from the merged star
                            bh_list.push(new BlackHole(new_pos, total_mass, new_vel));
                            
                            // Add more dramatic particles for black hole formation
                            for (let k = 0; k < 40; k++) {
                                const angle = Math.random() * 2 * Math.PI;
                                const speed = Math.random() * 120 + 60;
                                const p_vel = { 
                                    x: speed * Math.cos(angle), 
                                    y: speed * Math.sin(angle) 
                                };
                                particles.push(new Particle(new_pos, p_vel, Math.random()*1.0+0.8, 12, 3, 'rgb(255, 100, 0)'));
                            }
                            

                        } else {
                            // Create a new merged star
                            const merged_star = new StarObject(new_pos, new_vel, new_mass_in_suns);
                            stars_list.push(merged_star);
                            

                        }
                        
                        merged_this_step = true;
                        merge_count++;
                        break;
                    }
                }
                if (merged_this_step) break;
            }
        }
    };

    const handle_collisions = (objects_list) => {
        for (let i = 0; i < objects_list.length; i++) {
            const obj1 = objects_list[i]; if (!obj1.alive) continue;
            for (let j = i + 1; j < objects_list.length; j++) {
                const obj2 = objects_list[j]; if (!obj2.alive) continue;
                const dx = obj2.pos.x - obj1.pos.x; const dy = obj2.pos.y - obj1.pos.y;
                const dist_sq = dx*dx + dy*dy; const min_dist = obj1.radius + obj2.radius;
                if (dist_sq < min_dist**2 && dist_sq > 1e-6) {
                    const dist = Math.sqrt(dist_sq); const overlap = min_dist - dist;
                    const nx = dx / dist; const ny = dy / dist;
                    const total_mass = obj1.mass + obj2.mass;
                    const move1 = -overlap * (obj2.mass / total_mass); const move2 = overlap * (obj1.mass / total_mass);
                    obj1.pos.x += move1 * nx; obj1.pos.y += move1 * ny;
                    obj2.pos.x += move2 * nx; obj2.pos.y += move2 * ny;
                    const rvx = obj2.vel.x - obj1.vel.x; const rvy = obj2.vel.y - obj1.vel.y;
                    const vel_normal = rvx * nx + rvy * ny;
                    if (vel_normal < 0) {
                        const e = 0.8;
                        const j = -(1 + e) * vel_normal / (1/obj1.mass + 1/obj2.mass);
                        const impx = j * nx; const impy = j * ny;
                        obj1.vel.x -= impx / obj1.mass; obj1.vel.y -= impy / obj1.mass;
                        obj2.vel.x += impx / obj2.mass; obj2.vel.y += impy / obj2.mass;
                    }
                }
            }
        }
    }

    const apply_preset = (settings_dict) => {
        const ps = settings_dict.preset_scenario;
        if (ps === "None") return;
        const fresh_defaults = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
        Object.assign(settings_dict, fresh_defaults, { preset_scenario: ps });

        if (ps === "Binary BH") { Object.assign(settings_dict, { num_black_holes: 2, bh_behavior: "Orbiting", use_individual_bh_masses: true, bh_masses: [15, 10], num_planets: 10, num_asteroids: 30, placement: "Circular", init_velocity: 15 }); }
        else if (ps === "Triple BH System") { Object.assign(settings_dict, { num_black_holes: 3, bh_behavior: "Orbiting", use_individual_bh_masses: true, bh_masses: [20, 15, 10], num_planets: 20, num_asteroids: 40, placement: "Circular", init_velocity: 10, orbit_decay_rate: 0.001 }); }
        else if (ps === "Supermassive BH") { Object.assign(settings_dict, { num_black_holes: 1, bh_mass: 80, num_planets: 50, num_gas_giants: 5, num_asteroids: 100, init_velocity: 25, show_accretion_disk: true }); }
        else if (ps === "Star Cluster") { Object.assign(settings_dict, { num_black_holes: 0, num_planets: 100, num_gas_giants: 10, num_asteroids: 200, placement: "Grid", init_velocity: 5, gravitational_constant: 1.0 }); }
        else if (ps === "Kuiper Belt") { Object.assign(settings_dict, { placement: "Empty", mutual_gravity: true, num_black_holes: 0, num_planets: 8, num_gas_giants: 4, enable_asteroids: true, num_asteroids: 300 }); }
        else if (ps === "Sagittarius A*") { Object.assign(settings_dict, { num_black_holes: 1, bh_mass: 1000, bh_behavior: "Static", show_accretion_disk: true, show_bh_glow: true, num_planets: 200, num_gas_giants: 10, num_asteroids: 50, placement: "Random", init_velocity: 60, velocity_stddev: 20 }); }
        else if (ps === "Binary Star System") { Object.assign(settings_dict, { num_black_holes: 0, mutual_gravity: true, placement: "Empty", num_planets: 5 }); }
        else if (ps === "Slingshot") { Object.assign(settings_dict, { placement: "Empty", num_black_holes: 2, use_individual_bh_masses: true, bh_masses: [50, 2], bh_behavior: "Orbiting", num_planets: 15 }); }
        else if (ps === "Rogue Encounter") { Object.assign(settings_dict, { placement: "Empty", num_black_holes: 1, bh_mass: 25, mutual_gravity: true, num_planets: 8, num_gas_giants: 2 }); }
		else if (ps === "Galactic Collision"){
			Object.assign(settings_dict,{
				num_black_holes:2, bh_masses:[1500,1500], use_individual_bh_masses:true,
				bh_behavior:"Orbiting", num_planets:800, num_gas_giants:80,
				placement:"Random", init_velocity:80, velocity_stddev:40,
				enable_asteroids:false
			});
		}
		else if (ps === "Micro BH Swarm"){
			Object.assign(settings_dict,{
				num_black_holes:20, bh_mass:2, bh_behavior:"Orbiting",
				num_planets:0, num_gas_giants:0, enable_asteroids:false,
				placement:"Random", init_velocity:0, velocity_stddev:0,
				gravitational_constant:4.0
			});
		}
		else if (ps === "Exoplanet Lab"){
			Object.assign(settings_dict,{
				num_black_holes:0, num_planets:100, num_gas_giants:15,
				placement:"Multi-Ring", init_velocity:25, velocity_stddev:5,
				mutual_gravity:true, enable_asteroids:false
			});
		}
		else if (ps === "Solar System Lite") {
			Object.assign(settings_dict, {
				num_black_holes: 0, num_planets: 8, num_gas_giants: 0, enable_asteroids: true, num_asteroids: 200, bh_behavior: "Static", placement: "Circular", init_velocity: 15, sim_speed: 0.5
			});
		}
		else if (ps === "Double Pulsar") {
			Object.assign(settings_dict, {
				num_black_holes: 0, num_planets: 5, num_gas_giants: 0, enable_asteroids: false, bh_behavior: "Static", placement: "Empty", init_velocity: 35, sim_speed: 1.0
			});
		}
		else if (ps === "Sag A* Neighborhood") {
			Object.assign(settings_dict, {
				num_black_holes: 1, bh_mass: 4e6, num_planets: 0, num_gas_giants: 0, enable_asteroids: false, placement: "Random", init_velocity: 500, sim_speed: 0.2, show_accretion_disk: true, show_bh_glow: true
			});
		}
		else if (ps === "Galactic Bar") {
			Object.assign(settings_dict, {
				num_black_holes: 5, bh_behavior: "Orbiting", use_individual_bh_masses: true, bh_masses: [10, 8, 12, 9, 11], num_planets: 40, num_gas_giants: 6, placement: "Empty", init_velocity: 30, orbit_decay_rate: 0.0, sim_speed: 0.7
			});
		}
		else if (ps === "Quasar Feast") {
			Object.assign(settings_dict, {
				num_black_holes: 1, bh_mass: 100, num_planets: 0, num_gas_giants: 0, enable_asteroids: true, num_asteroids: 800, show_accretion_disk: true, show_bh_glow: true, placement: "Random", init_velocity: 5, sim_speed: 0.4
			});
		}
		else if (ps === "Trappist-1x") {
			Object.assign(settings_dict, {
				num_black_holes: 0, num_planets: 7, num_gas_giants: 0, placement: "Circular", init_velocity: 8, velocity_stddev: 1, sim_speed: 0.6
			});
		}
		else if (ps === "Rogue Planet Cloud") {
			Object.assign(settings_dict, {
				num_black_holes: 0, num_planets: 200, num_gas_giants: 0, enable_asteroids: false, placement: "Random", init_velocity: 3, velocity_stddev: 2, sim_speed: 1.0
			});
		}
		else if (ps === "Dyson Swarm") {
			Object.assign(settings_dict, {
				num_black_holes: 0, num_planets: 0, num_gas_giants: 0, enable_asteroids: true, num_asteroids: 100, placement: "Empty", init_velocity: 10, sim_speed: 0.5
			});
		}
		else if (ps === "Wormhole Chase") {
			Object.assign(settings_dict, {
				num_black_holes: 2, bh_behavior: "Static", use_individual_bh_masses: true, bh_masses: [15, 15], num_planets: 30, enable_asteroids: true, num_asteroids: 150, placement: "Circular", init_velocity: 20, sim_speed: 0.8
			});
		}
		else if (ps === "Ringworld Mayhem") {
			Object.assign(settings_dict, {
				num_black_holes: 1, bh_mass: 0, num_planets: 0, num_gas_giants: 0, enable_asteroids: true, num_asteroids: 1200, placement: "Empty", init_velocity: 9, velocity_stddev: 0.5, sim_speed: 0.9
			});
		}

        settings_dict.preset_scenario = "None";
    }

    let current_scenario_name = null; // Store the current scenario name

    const show_scenario_info = () => {
        const scenarioInfoDiv = document.getElementById('scenarioInfoDisplay');
        
        if (current_scenario_name && current_scenario_name !== 'None' && SCENARIO_INFO[current_scenario_name]) {
            const info = SCENARIO_INFO[current_scenario_name];
            scenarioInfoDiv.innerHTML = `<h4>${info.title}</h4><p>${info.summary}</p>`;
            scenarioInfoDiv.classList.add('visible');
            setTimeout(() => scenarioInfoDiv.classList.remove('visible'), 6000);
        } else {
            scenarioInfoDiv.classList.remove('visible');
        }
    };

    const initialize_simulation = () => {
        const starting_preset = SETTINGS.preset_scenario;
        current_scenario_name = starting_preset; // Store the scenario name before it gets reset
        apply_preset(SETTINGS);
        // Restore the scenario name since apply_preset resets it to "None"
        if (starting_preset !== "None") {
            current_scenario_name = starting_preset;
        }

        state.zoom = 1.0; state.pan = { x: 0.0, y: 0.0 };
        bh_list = []; planets = []; stars = []; gas_giants = []; asteroids = [];
        debris = []; particles = []; gravity_ripples = []; PhysicsObject_id_counter = 0;

        // --- Add central stars for specific presets that need them BEFORE general placement ---
        if (["Kuiper Belt", "Rogue Encounter", "Exoplanet Lab", "Solar System Lite", "Trappist-1x"].includes(starting_preset)) {
            stars.push(new StarObject({ x: 0, y: 0 }, { x: 0, y: 0 }, 1.0)); // Add a 1 Msun star
        }

        // --- Handle special setup presets that have their own placement logic ---
        if (starting_preset === "Binary Star System") {
            stars.push(new StarObject({x: -50, y: 0}, {x: 0, y: 10})); // These get random mass/size/color
            stars.push(new StarObject({x: 50, y: 0}, {x: 0, y: -10}));
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 250 + Math.random() * 50;
                const theta = Math.random() * 2 * Math.PI;
                planets.push(new Planet({x: r * Math.cos(theta), y: r*Math.sin(theta)}, {x:0, y:0}));
            }
        } else if (starting_preset === "Kuiper Belt") {
            const central_mass = stars[0].mass;
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 50 + i * 25;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                planets.push(new Planet({x: r, y:0}, {x:0, y:v}));
            }
            for(let i=0; i < SETTINGS.num_gas_giants; i++) {
                const r = 250 + i * 50;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                gas_giants.push(new GasGiant({x: r, y:0}, {x:0, y:v * 0.8}));
            }
            if (SETTINGS.enable_asteroids) {
                for (let i = 0; i < SETTINGS.num_asteroids; i++) {
                    const r = 400 + Math.random() * 150;
                    const theta = Math.random() * 2 * Math.PI;
                    const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                    const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                    asteroids.push(new Asteroid(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }));
                }
            }
        } else if (starting_preset === "Rogue Encounter") {
            const central_mass = stars[0].mass;
            for(let i=0; i<SETTINGS.num_planets; i++) {
                const r = 50 + i * 20;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                planets.push(new Planet({x: r, y:0}, {x:0, y:v}));
            }
            bh_list.push(new BlackHole({x: -1000, y: 300}, 25 * SOLAR_MASS_UNIT, {x: 15, y: -5}));
        } else if (starting_preset === "Triple BH System") {
            const m = SETTINGS.bh_masses;
            bh_list.push(new BlackHole({x: 0, y: 150}, m[0] * SOLAR_MASS_UNIT, {x: -12, y: 0}));
            bh_list.push(new BlackHole({x: -130, y: -75}, m[1] * SOLAR_MASS_UNIT, {x: 6, y: -10}));
            bh_list.push(new BlackHole({x: 130, y: -75}, m[2] * SOLAR_MASS_UNIT, {x: 6, y: 10}));
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 450 + Math.random() * 100;
                const theta = Math.random() * 2 * Math.PI;
                planets.push(new Planet({x: r * Math.cos(theta), y: r*Math.sin(theta) }, {x:0, y:0}));
            }
        } else if (starting_preset === "Slingshot") {
            bh_list.push(new BlackHole({x: 0, y: 0}, 50 * SOLAR_MASS_UNIT, {x: 0, y: -0.5}));
            bh_list.push(new BlackHole({x: -800, y: 150}, 2 * SOLAR_MASS_UNIT, {x: 35, y: 0}));
            for(let i=0; i<SETTINGS.num_planets; i++) {
                const r = Math.random()*200 + 100;
                const theta = Math.random() * Math.PI * 2;
                planets.push(new Planet({x: r*Math.cos(theta), y: r*Math.sin(theta)}, {x:0, y:0}));
            }
        } else if (starting_preset === "Solar System Lite") {
            const central_mass = stars[0].mass;
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 50 + i * 30;
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                planets.push(new Planet({x: r, y:0}, {x:0, y:v}));
            }
            if (SETTINGS.enable_asteroids) {
                for (let i = 0; i < SETTINGS.num_asteroids; i++) {
                    const r = 300 + Math.random() * 200;
                    const theta = Math.random() * 2 * Math.PI;
                    const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                    const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                    asteroids.push(new Asteroid(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }));
                }
            }
        } else if (starting_preset === "Double Pulsar") {
            // Add two neutron stars (represented as compact stars) in tight orbit
            stars.push(new StarObject({x: -15, y: 0}, {x: 0, y: 25}, 1.4));
            stars.push(new StarObject({x: 15, y: 0}, {x: 0, y: -25}, 1.4));
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 200 + Math.random() * 100;
                const theta = Math.random() * 2 * Math.PI;
                planets.push(new Planet({x: r * Math.cos(theta), y: r*Math.sin(theta)}, {x:0, y:0}));
            }
        } else if (starting_preset === "Trappist-1x") {
            const central_mass = stars[0].mass * 0.09; // Red dwarf mass
            stars[0].mass = central_mass; // Update the star's mass
            for(let i=0; i < SETTINGS.num_planets; i++) {
                const r = 20 + i * 8; // Tight orbits like Trappist-1
                const v = Math.sqrt((SETTINGS.gravitational_constant * central_mass) / r);
                planets.push(new Planet({x: r, y:0}, {x:0, y:v}));
            }
        } else if (starting_preset === "Dyson Swarm") {
            // Create 100 small satellites in orbit around the center
            for(let i=0; i < SETTINGS.num_asteroids; i++) {
                const r = 50 + Math.random() * 100;
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * 1000) / r); // Use a central mass
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                const asteroid = new Asteroid(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) });
                asteroid.radius = 1; // Make them smaller like satellites
                asteroids.push(asteroid);
            }
        } else if (starting_preset === "Sag A* Neighborhood") {
            // Add high-speed S-stars around the supermassive black hole
            for(let i=0; i < 20; i++) {
                const r = 50 + Math.random() * 200;
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * SETTINGS.bh_mass * SOLAR_MASS_UNIT) / r);
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                const star = new StarObject(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }, 0.5 + Math.random() * 2.0);
                stars.push(star);
            }
        } else if (starting_preset === "Galactic Bar") {
            // Create a bar formation of 5 black holes
            const bar_length = 200;
            const bar_width = 40;
            const masses = SETTINGS.bh_masses;
            for(let i=0; i < 5; i++) {
                const x = (i - 2) * bar_length / 4; // Spread across the bar
                const y = (Math.random() - 0.5) * bar_width;
                const orbit_speed = 8;
                const angle = Math.atan2(y, x);
                const vel = {x: -orbit_speed * Math.sin(angle), y: orbit_speed * Math.cos(angle)};
                bh_list.push(new BlackHole({x: x, y: y}, masses[i] * SOLAR_MASS_UNIT, vel));
            }
        } else if (starting_preset === "Ringworld Mayhem") {
            // Create a massive ring of asteroids with a central "hole" (0 mass BH)
            bh_list.push(new BlackHole({x: 0, y: 0}, 0 * SOLAR_MASS_UNIT)); // 0 mass black hole
            for(let i=0; i < SETTINGS.num_asteroids; i++) {
                const r = 150 + Math.random() * 50; // Ring formation
                const theta = Math.random() * 2 * Math.PI;
                const v = Math.sqrt((SETTINGS.gravitational_constant * 1000) / r); // Use some central mass for orbital velocity
                const pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                asteroids.push(new Asteroid(pos, { x: -v * Math.sin(theta), y: v * Math.cos(theta) }));
            }
        } else {
             // --- Standard placement logic for all other presets ---
            const num_bh = SETTINGS.num_black_holes;
            if (num_bh === 1 && bh_list.length === 0) { bh_list.push(new BlackHole({x:0, y:0}, SETTINGS.bh_mass * SOLAR_MASS_UNIT)); } 
            else if (num_bh > 1) {
                const masses = (SETTINGS.use_individual_bh_masses && SETTINGS.bh_masses.length === num_bh) ? SETTINGS.bh_masses : Array(num_bh).fill(SETTINGS.bh_mass);
                const bh_initial_radius = 150;
                for (let i = 0; i < num_bh; i++) {
                    const angle = 2 * Math.PI * i / num_bh;
                    const pos = {x: bh_initial_radius * Math.cos(angle), y: bh_initial_radius * Math.sin(angle)};
                    let vel = {x: 0, y: 0};
                    if (SETTINGS.bh_behavior === "Orbiting") {
                        const orbit_speed = 8;
                        vel = {x: -orbit_speed * Math.sin(angle), y: orbit_speed * Math.cos(angle)};
                    }
                    bh_list.push(new BlackHole(pos, masses[i] * SOLAR_MASS_UNIT, vel));
                }
            }
            
            const central_body = (stars.length === 1 && bh_list.length === 0) ? stars[0] : 
                                 (bh_list.length === 1 && stars.length === 0) ? bh_list[0] : null;

            const get_orbital_velocity = (pos, center_obj) => {
                const r_vec = { x: pos.x - (center_obj?.pos.x || 0), y: pos.y - (center_obj?.pos.y || 0) };
                const r = Math.hypot(r_vec.x, r_vec.y);
                if (r < 1) return {x:0, y:0};

                let vel_mag;
                if (center_obj) { // Calculate proper orbital velocity
                    vel_mag = Math.sqrt(SETTINGS.gravitational_constant * center_obj.mass / r);
                } else { // Fallback to user setting for chaotic systems
                    vel_mag = SETTINGS.init_velocity + (Math.random() - 0.5) * 2 * SETTINGS.velocity_stddev;
                }
                return { x: -vel_mag * (r_vec.y / r), y: vel_mag * (r_vec.x / r) };
            };
            
            const min_radius = (num_bh > 0 || stars.length > 0) ? 100 : 50;
            const max_radius = { "Small": 200, "Medium": 300, "Large": 400, "Huge": 500 }[SETTINGS.sim_size] || 400;

            const placementFunc = (index, count) => {
                let pos;
                switch(SETTINGS.placement) {
                    case "Random": {
                        const r = min_radius + Math.random() * (max_radius - min_radius);
                        const theta = Math.random() * 2 * Math.PI;
                        pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                        break;
                    }
                    case "Grid": {
                        const num_per_side = Math.ceil(Math.sqrt(count));
                        const spacing = (max_radius * 1.5) / num_per_side;
                        const grid_x = (index % num_per_side) - (num_per_side / 2) + 0.5;
                        const grid_y = Math.floor(index / num_per_side) - (num_per_side / 2) + 0.5;
                        pos = { x: grid_x * spacing, y: grid_y * spacing };
                        break;
                    }
                    case "Multi-Ring": {
                        const num_rings = 4;
                        const ring_index = index % num_rings;
                        const r = min_radius + (ring_index / (num_rings - 1)) * (max_radius - min_radius);
                        const objects_in_prev_rings = Math.floor(count/num_rings) * ring_index + Math.min(count % num_rings, ring_index);
                        const index_in_this_ring = index - objects_in_prev_rings;
                        const count_in_this_ring = Math.floor(count/num_rings) + (ring_index < (count % num_rings) ? 1 : 0);
                        const theta = 2 * Math.PI * (index_in_this_ring / (count_in_this_ring || 1));
                        pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                        break;
                    }
                    case "Circular":
                    default: {
                        const theta = 2 * Math.PI * index / count; 
                        const r = min_radius + (max_radius - min_radius) / 2;
                        pos = { x: r * Math.cos(theta), y: r * Math.sin(theta) };
                        break;
                    }
                }
                return { pos, vel: get_orbital_velocity(pos, central_body) };
            };

            if (SETTINGS.placement !== 'Empty') {
                for (let i = 0; i < SETTINGS.num_planets; i++) { const {pos, vel} = placementFunc(i, SETTINGS.num_planets); planets.push(new Planet(pos, vel)); }
                for (let i = 0; i < SETTINGS.num_gas_giants; i++) { const {pos, vel} = placementFunc(i, SETTINGS.num_gas_giants); gas_giants.push(new GasGiant(pos, vel)); }
                if (SETTINGS.enable_asteroids) {
                    for (let i = 0; i < SETTINGS.num_asteroids; i++) {
                        const {pos, vel} = placementFunc(i, SETTINGS.num_asteroids);
                        asteroids.push(new Asteroid(pos, vel));
                    }
                }
            }
        }

        generateStarfield();

        let max_object_dist = 0;
        [...bh_list, ...planets, ...gas_giants, ...asteroids, ...stars].forEach(obj => {
            max_object_dist = Math.max(max_object_dist, Math.hypot(obj.pos.x, obj.pos.y));
        });

        if (max_object_dist > 0) {
            const margin = 1.2;
            const required_zoom_x = (canvas.width * 0.8) / (max_object_dist * 2 * margin);
            const required_zoom_y = (canvas.height * 0.8) / (max_object_dist * 2 * margin);
            state.zoom = Math.min(required_zoom_x, required_zoom_y, 1.0);
        }
    };

    const updatePhysics = (dt) => {
        if(dt <= 0) return;
        state.frame_count++;
        
        let major_sources = [...bh_list, ...stars, ...gas_giants];
        if (SETTINGS.mutual_gravity) {
            major_sources = [...bh_list, ...stars, ...gas_giants, ...planets, ...asteroids];
        }
        
        const all_physics_objects = [...planets, ...asteroids, ...gas_giants, ...debris, ...stars];
        all_physics_objects.forEach(obj => {
            let effective_sources = major_sources;
            if (SETTINGS.mutual_gravity) {
                effective_sources = major_sources.filter(s => s.id !== obj.id);
            }
            obj.update_physics(dt, effective_sources);
            if (SETTINGS.show_trails) obj.update_trail();
        });

        if (SETTINGS.bh_behavior === "Orbiting") bh_list.forEach(bh => bh.update_orbit(dt, bh_list));

        const new_debris = [];
        stars.forEach(star => {
            if (star.alive && star.intact) {
                const { debris_count, fraction } = star.tidal_mass_loss(bh_list, dt);
                if (debris_count > 0) {
                    for (let i = 0; i < debris_count; i++) {
                        const eject_speed = (Math.random() * 9 + 1) * (1 + fraction);
                        const angle = Math.random() * 2 * Math.PI;
                        const dv = { x: eject_speed * Math.cos(angle), y: eject_speed * Math.sin(angle) };
                        const spawn_pos = { x: star.pos.x + Math.random()*4-2, y: star.pos.y + Math.random()*4-2 };
                        new_debris.push(new Debris(spawn_pos, {x: star.vel.x*0.1+dv.x, y: star.vel.y*0.1+dv.y}));
                    }
                }
            }
        });
        debris.push(...new_debris);

        // Handle star merging separately from other collisions
        if (SETTINGS.enable_star_merging) {
            handle_star_merging(stars);
        }
        // Handle collisions for non-star objects
        handle_collisions([...planets, ...asteroids]);
        
        const check_and_absorb = (obj_list) => {
            return obj_list.filter(obj => {
                if(obj.alive && obj.check_absorption(bh_list)) {
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * 2 * Math.PI, speed = Math.random() * 50 + 30;
                        const p_vel = { x: speed * Math.cos(angle), y: speed * Math.sin(angle) };
                        const color_key = `${obj.obj_type.toLowerCase()}_base_color`;
                        const baseColor = obj.baseColor || SETTINGS[color_key] || '#c8c8c8';
                        const rgb = hexToRgb(baseColor);
                        particles.push(new Particle(obj.pos, p_vel, Math.random()*0.6+0.4, 5, 1, `rgb(${rgb.r},${rgb.g},${rgb.b})`));
                    }
                    return false;
                }
                return obj.alive;
            });
        };

        planets = check_and_absorb(planets); stars = check_and_absorb(stars);
        gas_giants = check_and_absorb(gas_giants); asteroids = check_and_absorb(asteroids);
        debris = check_and_absorb(debris);
        
        particles = particles.filter(p => p.is_alive());
        particles.forEach(p => p.update(dt));
        
        // Update gravity ripples
        gravity_ripples = gravity_ripples.filter(r => r.is_alive());
        gravity_ripples.forEach(r => r.update(dt));

        let merged_this_step = true;
        while (merged_this_step && bh_list.length > 1) {
            merged_this_step = false;
            for (let i = 0; i < bh_list.length; i++) {
                for (let j = i + 1; j < bh_list.length; j++) {
                    const bh1 = bh_list[i], bh2 = bh_list[j]; const dx = bh1.pos.x - bh2.pos.x, dy = bh1.pos.y - bh2.pos.y;
                    if (dx*dx + dy*dy < (bh1.radius + bh2.radius)**2) {
                        const m1 = bh1.mass, m2 = bh2.mass, new_mass = m1 + m2;
                        const new_pos = { x: (bh1.pos.x * m1 + bh2.pos.x * m2) / new_mass, y: (bh1.pos.y * m1 + bh2.pos.y * m2) / new_mass };
                        const new_vel = { x: (bh1.vel.x * m1 + bh2.vel.x * m2) / new_mass, y: (bh1.vel.y * m1 + bh2.vel.y * m2) / new_mass };
                        
                        // Create gravity ripple effect
                        const mass_factor = Math.sqrt(new_mass / (DEFAULT_SETTINGS.bh_mass * SOLAR_MASS_UNIT));
                        gravity_ripples.push(new GravityRipple(new_pos, mass_factor));
                        
                        bh_list.splice(j, 1); bh_list.splice(i, 1);
                        bh_list.push(new BlackHole(new_pos, new_mass, new_vel));
                        merged_this_step = true;
                        break;
                    }
                }
                if (merged_this_step) break;
            }
        }
        
        planets = planets.filter(p => !is_offscreen(p.pos)); stars = stars.filter(s => !is_offscreen(s.pos));
        gas_giants = gas_giants.filter(g => !is_offscreen(g.pos)); asteroids = asteroids.filter(a => !is_offscreen(a.pos));
        debris = debris.filter(d => !is_offscreen(d.pos));

        let target = null;
        if (SETTINGS.follow_mode !== "None") {
            const follow_map = { "BlackHole": bh_list, "Planet": planets, "GasGiant": gas_giants, "Star": stars };
            const target_list = follow_map[SETTINGS.follow_mode];
            if (target_list && target_list.length > 0) {
                if (target_list.length > 1) {
                    let totalMass = 0, com = {x:0, y:0};
                    target_list.forEach(obj => { com.x += obj.pos.x * obj.mass; com.y += obj.pos.y * obj.mass; totalMass += obj.mass; });
                    if (totalMass > 0) target = { pos: { x: com.x/totalMass, y: com.y/totalMass }};
                } else { target = target_list[0]; }
            }
        }
        if (target) { state.pan.x = -target.pos.x * state.zoom; state.pan.y = target.pos.y * state.zoom; }
    }

    const drawScene = () => {
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        ctx.translate(canvas.width / 2 + state.pan.x, canvas.height / 2 + state.pan.y);
        ctx.scale(state.zoom, -state.zoom);


        if (SETTINGS.show_trails) {
            [...planets, ...gas_giants, ...asteroids, ...stars].forEach(obj => {
                if (obj.alive && obj.trail.length > 1) {
                    const baseColor = obj.baseColor || SETTINGS[`${obj.obj_type.toLowerCase()}_base_color`] || '#6495ed';
                    const rgb = hexToRgb(baseColor);
                    
                    if (SETTINGS.trail_style === "Cloud") {
                        // Draw cloud-like trail with multiple passes
                        for (let pass = 0; pass < 3; pass++) {
                            const trailWidth = (2.5 - pass * 0.5) / state.zoom;
                            const maxAlpha = 0.6 - pass * 0.15;
                            
                            ctx.lineWidth = trailWidth;
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            
                            // Create gradient for the trail
                            const gradient = ctx.createLinearGradient(0, 0, 0, 0);
                            gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${maxAlpha})`);
                            gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                            
                            ctx.strokeStyle = gradient;
                            ctx.beginPath();
                            
                            // Draw trail with smooth curves and fade-out
                            const first_point = world_to_screen(obj.trail[0]);
                            ctx.moveTo(first_point.x, first_point.y);
                            
                            for (let i = 1; i < obj.trail.length; i++) {
                                const point = world_to_screen(obj.trail[i]);
                                const age_factor = 1 - (obj.trail[i].age / SETTINGS.trail_length);
                                const velocity_factor = Math.min(1, obj.trail[i].velocity / 50);
                                const alpha = age_factor * velocity_factor * maxAlpha;
                                
                                ctx.globalAlpha = alpha;
                                
                                // Use quadratic curves for smoother trails
                                if (i < obj.trail.length - 1) {
                                    const next_point = world_to_screen(obj.trail[i + 1]);
                                    const cp_x = (point.x + next_point.x) / 2;
                                    const cp_y = (point.y + next_point.y) / 2;
                                    ctx.quadraticCurveTo(point.x, point.y, cp_x, cp_y);
                                } else {
                                    ctx.lineTo(point.x, point.y);
                                }
                            }
                            ctx.stroke();
                        }
                        
                        // Draw bright core trail
                        ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.9)`;
                        ctx.lineWidth = 1.0 / state.zoom;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        
                        const first_point = world_to_screen(obj.trail[0]);
                        ctx.moveTo(first_point.x, first_point.y);
                        
                        for (let i = 1; i < obj.trail.length; i++) {
                            const point = world_to_screen(obj.trail[i]);
                            const age_factor = 1 - (obj.trail[i].age / SETTINGS.trail_length);
                            ctx.globalAlpha = age_factor * 0.9;
                            ctx.lineTo(point.x, point.y);
                        }
                        ctx.stroke();
                        
                    } else if (SETTINGS.trail_style === "Glow") {
                        // Draw glowing trail with radial gradients
                        for (let i = 0; i < obj.trail.length; i++) {
                            const point = world_to_screen(obj.trail[i]);
                            const age_factor = 1 - (obj.trail[i].age / SETTINGS.trail_length);
                            const velocity_factor = Math.min(1, obj.trail[i].velocity / 50);
                            const intensity = age_factor * velocity_factor;
                            
                            if (intensity > 0.05) {
                                const radius = (3 + intensity * 5) / state.zoom;
                                const gradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, radius);
                                gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${intensity * 0.8})`);
                                gradient.addColorStop(0.5, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${intensity * 0.3})`);
                                gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                                
                                ctx.fillStyle = gradient;
                                ctx.beginPath();
                                ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                        
                    } else { // Simple style
                        // Draw simple trail with fade-out
                        ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.8)`;
                        ctx.lineWidth = 1.5 / state.zoom;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        
                        const first_point = world_to_screen(obj.trail[0]);
                        ctx.moveTo(first_point.x, first_point.y);
                        
                        for (let i = 1; i < obj.trail.length; i++) {
                            const point = world_to_screen(obj.trail[i]);
                            const age_factor = 1 - (obj.trail[i].age / SETTINGS.trail_length);
                            ctx.globalAlpha = age_factor * 0.8;
                            ctx.lineTo(point.x, point.y);
                        }
                        ctx.stroke();
                    }
                }
            });
            ctx.globalAlpha = 1; 
        }

        [...debris, ...asteroids, ...planets, ...gas_giants, ...stars].forEach(obj => { if (obj.alive) obj.draw(ctx); });
        
        particles.forEach(p => p.draw(ctx));
        
        // Draw gravity ripples (behind black holes)
        gravity_ripples.forEach(r => r.draw(ctx));
        
        ctx.globalAlpha = 1;
        
        bh_list.forEach(bh => bh.draw(ctx));

        ctx.restore();
        
        if (state.adding_mass) {
            // Draw drag line
            ctx.strokeStyle = 'lime'; 
            ctx.lineWidth = 3; 
            ctx.lineCap = 'round';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(state.add_start_screen.x, state.add_start_screen.y);
            ctx.lineTo(state.mouse.x, state.mouse.y); 
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw start point
            ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(state.add_start_screen.x, state.add_start_screen.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw end point
            ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(state.mouse.x, state.mouse.y, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw velocity arrow
            const dx = state.mouse.x - state.add_start_screen.x;
            const dy = state.mouse.y - state.add_start_screen.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 20) {
                const angle = Math.atan2(dy, dx);
                const arrowLength = 20;
                const arrowAngle = Math.PI / 6;
                
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(state.mouse.x, state.mouse.y);
                ctx.lineTo(
                    state.mouse.x - arrowLength * Math.cos(angle - arrowAngle),
                    state.mouse.y - arrowLength * Math.sin(angle - arrowAngle)
                );
                ctx.moveTo(state.mouse.x, state.mouse.y);
                ctx.lineTo(
                    state.mouse.x - arrowLength * Math.cos(angle + arrowAngle),
                    state.mouse.y - arrowLength * Math.sin(angle + arrowAngle)
                );
                ctx.stroke();
            }
        }

        if (SETTINGS.show_dynamic_overlays) {
            const lines = [ `Planets: ${planets.length} | Gas Giants: ${gas_giants.length} | Asteroids: ${asteroids.length}`, `Stars: ${stars.length} | Black Holes: ${bh_list.length}`, `Particles: ${particles.length} | Debris: ${debris.length}`, `---`, `Zoom: ${state.zoom.toFixed(2)}x | Sim Speed: ${SETTINGS.sim_speed.toFixed(1)}x`, `Status: ${state.paused ? 'Paused (Space)' : 'Running'}` ];
            overlayDiv.innerHTML = lines.join('<br>');
        } else {
            overlayDiv.innerHTML = '';
        }
    };
    
    const gameLoop = (timestamp) => {
        if (!state.last_time) state.last_time = timestamp; 
        const dt_seconds = (timestamp - state.last_time) / 1000.0;
        state.last_time = timestamp;
        const dt_sim = Math.min(dt_seconds, 0.05) * SETTINGS.sim_speed * 50 * DT;
        if (!state.paused) updatePhysics(dt_sim);
        drawScene();
        requestAnimationFrame(gameLoop);
    };

	function resizeCanvas(){
		const W = window.innerWidth;
		const H = window.innerHeight;
		canvas.width  = W;  canvas.height  = H;        // sim layer
		starfieldCanvas.width  = W; starfieldCanvas.height = H; // star layer
		generateStarfield();                           // redraw background
	}
	window.addEventListener('resize', resizeCanvas);


    canvas.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        const uiContainer = document.querySelector('.ui-container');
        if (e.clientX > uiContainer.getBoundingClientRect().left) return;
        state.mouse.down = true;
        if (SETTINGS.interactive_add) {
            state.adding_mass = true;
            state.add_start_screen = { x: e.clientX, y: e.clientY };
            state.add_start_world = screen_to_world(state.add_start_screen);
        }
    });

    window.addEventListener('mousemove', (e) => {
        state.mouse.x = e.clientX; state.mouse.y = e.clientY;
        if (state.mouse.down && !state.adding_mass) { state.pan.x += e.movementX; state.pan.y += e.movementY; }
    });
    
    window.addEventListener('mouseup', (e) => {
        if (e.button !== 0) return;
        state.mouse.down = false;
        if (state.adding_mass) {
            state.adding_mass = false;
            const add_end_world = screen_to_world({ x: e.clientX, y: e.clientY });
            const vel = { x: (add_end_world.x - state.add_start_world.x) * 3, y: (add_end_world.y - state.add_start_world.y) * 3 };
            const type = SETTINGS.input_object_type; let new_obj;
            if (type === 'Planet') new_obj = new Planet(state.add_start_world, vel);
            else if (type === 'Star') new_obj = new StarObject(state.add_start_world, vel);
            else if (type === 'Asteroid') new_obj = new Asteroid(state.add_start_world, vel);
            else if (type === 'GasGiant') new_obj = new GasGiant(state.add_start_world, vel);
            if(new_obj instanceof Planet) planets.push(new_obj);
            if(new_obj instanceof StarObject) stars.push(new_obj);
            if(new_obj instanceof Asteroid) asteroids.push(new_obj);
            if(new_obj instanceof GasGiant) gas_giants.push(new_obj);
        }
    });

    // Touch event handlers for mobile
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            const uiContainer = document.querySelector('.ui-container');
            if (touch.clientX > uiContainer.getBoundingClientRect().left) return;
            
            state.touch_active = true;
            state.touch_id = touch.identifier;
            state.mouse.x = touch.clientX;
            state.mouse.y = touch.clientY;
            
            if (SETTINGS.interactive_add) {
                state.adding_mass = true;
                state.add_start_screen = { x: touch.clientX, y: touch.clientY };
                state.add_start_world = screen_to_world(state.add_start_screen);
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (state.touch_active && e.touches.length === 1) {
            const touch = e.touches[0];
            if (touch.identifier === state.touch_id) {
                state.mouse.x = touch.clientX;
                state.mouse.y = touch.clientY;
                
                // Pan the view if not adding mass
                if (!state.adding_mass) {
                    const deltaX = touch.clientX - (state.mouse.x - e.movementX || touch.clientX);
                    const deltaY = touch.clientY - (state.mouse.y - e.movementY || touch.clientY);
                    state.pan.x += deltaX;
                    state.pan.y += deltaY;
                }
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (state.touch_active && e.changedTouches.length === 1) {
            const touch = e.changedTouches[0];
            if (touch.identifier === state.touch_id) {
                state.touch_active = false;
                state.touch_id = null;
                
                if (state.adding_mass) {
                    state.adding_mass = false;
                    const add_end_world = screen_to_world({ x: touch.clientX, y: touch.clientY });
                    const vel = { x: (add_end_world.x - state.add_start_world.x) * 3, y: (add_end_world.y - state.add_start_world.y) * 3 };
                    const type = SETTINGS.input_object_type; let new_obj;
                    if (type === 'Planet') new_obj = new Planet(state.add_start_world, vel);
                    else if (type === 'Star') new_obj = new StarObject(state.add_start_world, vel);
                    else if (type === 'Asteroid') new_obj = new Asteroid(state.add_start_world, vel);
                    else if (type === 'GasGiant') new_obj = new GasGiant(state.add_start_world, vel);
                    if(new_obj instanceof Planet) planets.push(new_obj);
                    if(new_obj instanceof StarObject) stars.push(new_obj);
                    if(new_obj instanceof Asteroid) asteroids.push(new_obj);
                    if(new_obj instanceof GasGiant) gas_giants.push(new_obj);
                }
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        state.touch_active = false;
        state.touch_id = null;
        state.adding_mass = false;
    }, { passive: false });

	window.addEventListener('wheel', (e) => {
		if (e.target !== canvas) return;
		e.preventDefault(); 
        const zoomFactor = 1.1; const oldZoom = state.zoom;
        let newZoom = (e.deltaY < 0) ? oldZoom * zoomFactor : oldZoom / zoomFactor;
        newZoom = Math.max(0.01, Math.min(newZoom, 100));
        const worldPos = screen_to_world({x: e.clientX, y: e.clientY});
        state.zoom = newZoom;
        const newScreenPos = { x: worldPos.x * state.zoom + canvas.width / 2, y: -worldPos.y * state.zoom + canvas.height / 2 };
        state.pan.x -= (newScreenPos.x - e.clientX);
        state.pan.y -= (newScreenPos.y - e.clientY);
	}, { passive: false });

    // Pinch-to-zoom for mobile
    let initialDistance = 0;
    let initialZoom = 1.0;
    let initialPan = { x: 0, y: 0 };

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            initialZoom = state.zoom;
            initialPan = { ...state.pan };
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            
            if (initialDistance > 0) {
                const scale = currentDistance / initialDistance;
                const newZoom = Math.max(0.01, Math.min(100, initialZoom * scale));
                
                // Calculate center point for zoom
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                const worldPos = screen_to_world({ x: centerX, y: centerY });
                
                state.zoom = newZoom;
                const newScreenPos = { 
                    x: worldPos.x * state.zoom + canvas.width / 2, 
                    y: -worldPos.y * state.zoom + canvas.height / 2 
                };
                state.pan.x = initialPan.x - (newScreenPos.x - centerX);
                state.pan.y = initialPan.y - (newScreenPos.y - centerY);
            }
        }
    }, { passive: false });

    window.addEventListener('keydown', (e) => {
        const panSpeed = 40 / state.zoom;
        if (e.key === ' ') { state.paused = !state.paused; e.preventDefault(); } 
        else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') state.pan.x += panSpeed;
        else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') state.pan.x -= panSpeed;
        else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') state.pan.y += panSpeed;
        else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') state.pan.y -= panSpeed;
        else if (e.key.toLowerCase() === 'home') { state.zoom = 1.0; state.pan = {x: 0, y: 0}; }
        else if (e.key === '-' || e.key === '_') { 
            SETTINGS.sim_speed = Math.max(0.1, SETTINGS.sim_speed - 0.2);
            updateSpeedDisplay();
        }
        else if (e.key === '=' || e.key === '+') { 
            SETTINGS.sim_speed = Math.min(5.0, SETTINGS.sim_speed + 0.2);
            updateSpeedDisplay();
        }
    });
    
    // --- Save/Load Logic ---
    const save_simulation_state = () => {
        try {
            const savedState = { settings: SETTINGS, view: { zoom: state.zoom, pan: state.pan }, objects: [ ...bh_list.map(o => o.get_state()), ...planets.map(o => o.get_state()), ...stars.map(o => o.get_state()), ...gas_giants.map(o => o.get_state()), ...asteroids.map(o => o.get_state()), ...debris.map(o => o.get_state()) ] };
            localStorage.setItem(SAVE_KEY, JSON.stringify(savedState));
            alert("Simulation state saved!");
        } catch (e) { console.error("Error saving state:", e); alert("Failed to save simulation state."); }
    };
    
    const load_simulation_state = () => {
        const scenarioInfoDiv = document.getElementById('scenarioInfoDisplay');
        scenarioInfoDiv.classList.remove('visible');

        const savedJSON = localStorage.getItem(SAVE_KEY);
        if (!savedJSON) { alert("No saved state found."); return; }
        try {
            const loadedState = JSON.parse(savedJSON);
            SETTINGS = loadedState.settings || { ...DEFAULT_SETTINGS };
            const view = loadedState.view || { zoom: 1.0, pan: {x:0, y:0} };
            state.zoom = view.zoom; state.pan = view.pan;
            bh_list = []; planets = []; stars = []; gas_giants = []; asteroids = []; debris = []; particles = [];
            PhysicsObject_id_counter = 0; let max_id = 0;
            loadedState.objects.forEach(obj_state => {
                const { type, pos, vel, mass } = obj_state; let new_obj = null;
                if (type === 'Planet') new_obj = new Planet(pos, vel);
                else if (type === 'GasGiant') new_obj = new GasGiant(pos, vel);
                else if (type === 'Asteroid') new_obj = new Asteroid(pos, vel);
                else if (type === 'StarObject') new_obj = new StarObject(pos, vel);
                else if (type === 'Debris') new_obj = new Debris(pos, vel);
                else if (type === 'BlackHole') new_obj = new BlackHole(pos, mass, vel);
                if (new_obj) {
                    new_obj.set_state(obj_state);
                    if (new_obj instanceof Planet) planets.push(new_obj);
                    else if (new_obj instanceof GasGiant) gas_giants.push(new_obj);
                    else if (new_obj instanceof Asteroid) asteroids.push(new_obj);
                    else if (new_obj instanceof StarObject) stars.push(new_obj);
                    else if (new_obj instanceof Debris) debris.push(new_obj);
                    else if (new_obj instanceof BlackHole) bh_list.push(new_obj);
                    max_id = Math.max(max_id, new_obj.id || 0);
                }
            });
            PhysicsObject_id_counter = max_id + 1;
            alert("Simulation state loaded!"); state.paused = false;
            updateSpeedDisplay();
        } catch (e) { console.error("Error loading state:", e); alert("Failed to load state."); }
    }
    
	/* ----------  human-friendly titles & summaries  ---------- */
	const SCENARIO_INFO = {
	  "Binary BH":           {title:"Binary Black Hole", summary:"Two stellar-mass black holes locked in mutual orbit."},
	  "Triple BH System":    {title:"Triple Black Hole",  summary:"A chaotic three-body dance of massive BHs."},
	  "Supermassive BH":     {title:"Supermassive Core",  summary:"One huge BH dominating a dense stellar swarm."},
	  "Star Cluster":        {title:"Dense Star Cluster", summary:"Hundreds of stars with gentle mutual gravity."},
	  "Kuiper Belt":         {title:"Kuiper Belt",        summary:"A sun-like star with outer-system dust, ice and dwarf worlds."},
	  "Sagittarius A*":      {title:"Sagittarius A*",     summary:"The Milky Way’s central BH and its surrounding stars."},
	  "Binary Star System":  {title:"Binary Stars",       summary:"A pair of suns with orbiting planets."},
	  "Slingshot":           {title:"Gravity Slingshot",  summary:"Use a heavy BH to fling lighter bodies across the system."},
	  "Rogue Encounter":     {title:"Rogue Encounter",    summary:"A wandering black hole grazes a planetary system."},
	  "Galactic Collision":  {title:"Galactic Collision", summary:"Two super-massive BHs & thousands of stars on a crash course."},
	  "Micro BH Swarm":      {title:"Micro BH Swarm",     summary:"Dozens of tiny black holes interacting chaotically."},
	  "Exoplanet Lab":       {title:"Exoplanet Lab",      summary:"A sun-like star with 100+ varied planets for observation."},
	  "Solar System Lite":   {title:"Solar System Lite", summary:"A single sun, eight worlds & a sprinkle of asteroids — a playground for Kepler's laws."},
	  "Double Pulsar":       {title:"Double Pulsar", summary:"Two 1.4 M☉ neutron stars orbit each other every few seconds — can you keep planets stable?"},
	  "Sag A* Neighborhood": {title:"Sag A* Neighborhood", summary:"Super-massive BH (4 × 10⁶ M☉) with high-speed S-stars whizzing around every few hours."},
	  "Galactic Bar":        {title:"Galactic Bar", summary:"Five medium BHs stuck in a rotating bar — test bar-driven orbital chaos."},
	  "Quasar Feast":        {title:"Quasar Feast", summary:"A feeding 100 M☉ BH with a dense debris disk — watch the accretion light show."},
	  "Trappist-1x":         {title:"Trappist-1x", summary:"Seven Earth-size planets in tight resonant orbits around a red dwarf."},
	  "Rogue Planet Cloud":  {title:"Rogue Planet Cloud", summary:"A dark, BH-free sector filled with 200 wanderers. Can gravity self-organise?"},
	  "Dyson Swarm":         {title:"Dyson Swarm", summary:"100 tiny solar-collectors in Keplerian orbit; tinker with stability of megastructures."},
	  "Wormhole Chase":      {title:"Wormhole Chase", summary:"Two BHs linked by a fictional wormhole (teleport script hook) — sling planets through!"},
	  "Ringworld Mayhem":    {title:"Ringworld Mayhem", summary:"Ultra-massive ring of asteroids plus a central 0 M☉ hole — test self-collapsing rings."}
	};

	
    // --- Settings Menu ---
    const setting_items = [
        {"label": "Preset Scenario", "key": "preset_scenario", "type": "option", "options": ["None", "Binary BH", "Triple BH System", "Supermassive BH", "Star Cluster", "Kuiper Belt", "Sagittarius A*", "Binary Star System", "Slingshot","Rogue Encounter","Galactic Collision","Micro BH Swarm","Exoplanet Lab", "Solar System Lite", "Double Pulsar", "Sag A* Neighborhood", "Galactic Bar", "Quasar Feast", "Trappist-1x", "Rogue Planet Cloud", "Dyson Swarm", "Wormhole Chase", "Ringworld Mayhem"]},
        {"label": "--- Simulation ---", "type": "separator"},
        {"label": "Gravitational Constant", "key": "gravitational_constant", "type": "float", "min": 0.1, "max": 20.0, "step": 0.1},
        {"label": "Mutual Gravity (All)", "key": "mutual_gravity", "type": "bool"},
        {"label": "Simulation Speed", "key": "sim_speed", "type": "float", "min": 0.0, "max": 5.0, "step": 0.1},
        {"label": "Simulation Size", "key": "sim_size", "type": "option", "options": ["Small", "Medium", "Large", "Huge"]},
        {"label": "Placement", "key": "placement", "type": "option", "options": ["Circular", "Multi-Ring", "Random", "Grid", "Empty"]},
        {"label": "--- Black Holes ---", "type": "separator"},
        {"label": "Number of Black Holes", "key": "num_black_holes", "type": "int", "min": 0, "max": 10, "step": 1},
        {"label": "Default BH Mass (Msun)", "key": "bh_mass", "type": "float", "min": 0.1, "max": 1000, "step": 0.5},
        {"label": "Use Individual BH Masses", "key": "use_individual_bh_masses", "type": "bool"},
        {"label": "BH Behavior", "key": "bh_behavior", "type": "option", "options": ["Static", "Orbiting"]},
        {"label": "Orbit Decay Rate", "key": "orbit_decay_rate", "type": "float", "min": 0.0, "max": 0.1, "step": 0.001, "precision": 3},
        {"label": "--- Objects ---", "type": "separator"},
        {"label": "Number of Planets", "key": "num_planets", "type": "int", "min": 0, "max": 200, "step": 1},
        {"label": "Number of Gas Giants", "key": "num_gas_giants", "type": "int", "min": 0, "max": 50, "step": 1},
        {"label": "Enable Asteroids", "key": "enable_asteroids", "type": "bool"},
        {"label": "Number of Asteroids", "key": "num_asteroids", "type": "int", "min": 0, "max": 500, "step": 5},
        {"label": "Initial Velocity", "key": "init_velocity", "type": "float", "min": 0, "max": 100, "step": 1},
        {"label": "Velocity StdDev", "key": "velocity_stddev", "type": "float", "min": 0, "max": 50, "step": 1},
        {"label": "Input Object Type", "key": "input_object_type", "type": "option", "options": ["Planet", "Star", "Asteroid", "GasGiant"]},
        {"label": "Enable Star Merging", "key": "enable_star_merging", "type": "bool"},
        {"label": "Max Star Mass Before BH (Msun)", "key": "max_star_mass_before_bh", "type": "float", "min": 5.0, "max": 50.0, "step": 0.5},
        {"label": "--- Visuals ---", "type": "separator"},
        {"label": "Show Trails", "key": "show_trails", "type": "bool"},
        {"label": "Trail Style", "key": "trail_style", "type": "option", "options": ["Cloud", "Simple", "Glow"]},
        {"label": "Trail Length", "key": "trail_length", "type": "int", "min": 5, "max": 300, "step": 5},
        {"label": "Show BH Glow", "key": "show_bh_glow", "type": "bool"},
        {"label": "Show Accretion Disk", "key": "show_accretion_disk", "type": "bool"},
        {"label": "Show BH Jets", "key": "show_bh_jets", "type": "bool"},
        {"label": "Improved Lensing", "key": "improved_lensing", "type": "bool"},
        {"label": "Lensing Strength", "key": "lensing_strength", "type": "float", "min": 1, "max": 1000, "step": 10},
        {"label": "Star Field Density", "key": "star_density", "type": "int", "min": 0, "max": 30000, "step": 100},
        {"label": "Ambient Lighting", "key": "show_ambient_lighting", "type": "bool"},
        {"label": "Dynamic Object Colors", "key": "dynamic_object_properties", "type": "bool"},
        {"label": "Planet Base Color", "key": "planet_base_color", "type": "color"},
        {"label": "--- UI & Control ---", "type": "separator"},
        {"label": "Interactive Add", "key": "interactive_add", "type": "bool"},
        {"label": "Follow Mode", "key": "follow_mode", "type": "option", "options": ["None", "BlackHole", "Planet", "GasGiant", "Star"]},
        {"label": "Show Overlays", "key": "show_dynamic_overlays", "type": "bool"},
    ];

    const buildSettingsMenu = () => {
        settingsGrid.innerHTML = '';
        localSettings = JSON.parse(JSON.stringify(SETTINGS)); 
		/* ------ utility to show the chosen preset’s description ------ */
		function updatePresetInfo(presetName){
			const box = document.getElementById("presetInfo");
			const info = SCENARIO_INFO[presetName];
			if(!info || presetName === "None"){ box.innerHTML=""; box.style.display = 'none'; return; }
            box.style.display = 'block';
			box.innerHTML = `<h4>${info.title}</h4>${info.summary}`;
		}

        setting_items.forEach(item => {
            if (item.type === 'separator') {
                const sepDiv = document.createElement('div');
                sepDiv.className = 'setting-separator';
                if (item.label.includes("Visuals")) { // A bit of a hack to remove the now-redundant star color setting
                    const starColorSettingIndex = setting_items.findIndex(s => s.key === 'star_base_color');
                    if (starColorSettingIndex > -1) setting_items.splice(starColorSettingIndex, 1);
                }
                sepDiv.innerHTML = `<h3>${item.label}</h3><div class="line"></div>`;
                settingsGrid.appendChild(sepDiv);
                return;
            }

            const label = document.createElement('div'); label.className = 'setting-label'; label.textContent = item.label;
            const controlContainer = document.createElement('div'); controlContainer.className = 'setting-control';
            const value = localSettings[item.key];

            if (item.type === 'int' || item.type === 'float') {
                const slider = document.createElement('input'); slider.type = 'range'; slider.min = item.min; slider.max = item.max; slider.step = item.step; slider.value = value;
                const valueDisplay = document.createElement('span'); valueDisplay.className = 'value-display'; valueDisplay.textContent = Number(value).toFixed(item.precision || (item.type === 'float' ? 1 : 0));
                slider.oninput = () => {
                    const val = item.type === 'int' ? parseInt(slider.value) : parseFloat(slider.value);
                    localSettings[item.key] = val; valueDisplay.textContent = val.toFixed(item.precision || (item.type === 'float' ? 1 : 0));
                    if (item.key === 'num_black_holes' || item.key === 'use_individual_bh_masses') updateIndivBHMassButtonVisibility();
                };
                controlContainer.append(slider, valueDisplay);
            } else if (item.type === 'bool') {
                const button = document.createElement('button'); button.className = 'toggle-button'; button.textContent = value ? 'On' : 'Off';
                button.onclick = () => { localSettings[item.key] = !localSettings[item.key]; button.textContent = localSettings[item.key] ? 'On' : 'Off'; if (item.key === 'use_individual_bh_masses') updateIndivBHMassButtonVisibility(); };
                controlContainer.appendChild(button);
            } else if (item.type === 'option') {
                const select = document.createElement('select');
                item.options.forEach(opt => { const option = document.createElement('option'); option.value = option.textContent = opt; if (opt === value) option.selected = true; select.appendChild(option); });
                select.onchange = (e) => {
                    localSettings[item.key] = e.target.value;
                    if (item.key === 'preset_scenario') {
                        updatePresetInfo(e.target.value);
                        // Also update the main scenario info display
                        current_scenario_name = e.target.value;
                        show_scenario_info();
                    }
                };
				controlContainer.appendChild(select);
            } else if (item.type === 'color') {
                const colorInput = document.createElement('input'); colorInput.type = 'color'; colorInput.value = value;
                colorInput.oninput = () => { localSettings[item.key] = colorInput.value; };
                controlContainer.appendChild(colorInput);
            }

            settingsGrid.append(label, controlContainer);

            if (item.key === 'orbit_decay_rate') {
                const bhMassBtnContainer = document.createElement('div');
                bhMassBtnContainer.style.gridColumn = '1 / -1';
                bhMassBtnContainer.style.textAlign = 'center';
                bhMassBtnContainer.innerHTML = `<button id="indivBHMassBtn" class="ui-button" style="margin-top: 10px;">Set Individual BH Masses</button>`;
                settingsGrid.appendChild(bhMassBtnContainer);
                bhMassBtnContainer.firstElementChild.onclick = showIndivBHMassMenu;
            }
        });
        updateIndivBHMassButtonVisibility();
		updatePresetInfo(localSettings.preset_scenario);
    };
    
    const updateIndivBHMassButtonVisibility = () => {
        const btn = document.getElementById('indivBHMassBtn');
        if (btn) btn.style.display = localSettings.use_individual_bh_masses && localSettings.num_black_holes > 1 ? 'inline-block' : 'none';
    }
    
    const showIndivBHMassMenu = () => {
        const content = document.getElementById('bhMassesContent');
        content.innerHTML = '';
        const num_bh = localSettings.num_black_holes;
        if (!localSettings.bh_masses || localSettings.bh_masses.length !== num_bh) {
            localSettings.bh_masses = Array(num_bh).fill(localSettings.bh_mass);
        }

        for (let i = 0; i < num_bh; i++) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'bh-mass-item';

            const label = document.createElement('label');
            label.textContent = `Black Hole #${i + 1}:`;

            const controlDiv = document.createElement('div');
            controlDiv.className = 'bh-mass-control';

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = 0.1;
            slider.max = 1000;
            slider.step = 0.1;
            slider.value = localSettings.bh_masses[i];
            slider.dataset.index = i;

            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'value-display';
            valueDisplay.textContent = `${Number(slider.value).toFixed(1)} Msun`;

            slider.oninput = (e) => {
                const index = parseInt(e.target.dataset.index, 10);
                const val = parseFloat(e.target.value);
                localSettings.bh_masses[index] = val;
                valueDisplay.textContent = `${val.toFixed(1)} Msun`;
            };
            
            controlDiv.append(slider, valueDisplay);
            itemDiv.append(label, controlDiv);
            content.appendChild(itemDiv);
        }
        bhMassesModal.classList.remove('hidden');
    }
    
    document.getElementById('bhMassesDone').onclick = () => bhMassesModal.classList.add('hidden');
    document.getElementById('settingsBtn').onclick = () => { buildSettingsMenu(); settingsPanel.classList.remove('hidden'); state.paused = true; };
    document.getElementById('refreshScenarioBtn').onclick = () => { initialize_simulation(); state.paused = false; show_scenario_info(); updateSpeedDisplay(); };
    document.getElementById('resetAllBtn').onclick = () => { SETTINGS = JSON.parse(JSON.stringify(DEFAULT_SETTINGS)); initialize_simulation(); state.paused = false; show_scenario_info(); updateSpeedDisplay(); };
    document.getElementById('saveBtn').onclick = save_simulation_state;
    document.getElementById('loadBtn').onclick = load_simulation_state;
    document.getElementById('settingsApply').onclick = () => { SETTINGS = JSON.parse(JSON.stringify(localSettings)); settingsPanel.classList.add('hidden'); initialize_simulation(); state.paused = false; show_scenario_info(); updateSpeedDisplay(); };
    document.getElementById('settingsReset').onclick = () => { localSettings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS)); buildSettingsMenu(); };
    document.getElementById('settingsCancel').onclick = () => { settingsPanel.classList.add('hidden'); state.paused = false; };

    // Speed control functionality
    const updateSpeedDisplay = () => {
        const speedDisplay = document.getElementById('speedDisplay');
        speedDisplay.textContent = `${SETTINGS.sim_speed.toFixed(1)}x`;
    };

    document.getElementById('slowDownBtn').onclick = () => {
        SETTINGS.sim_speed = Math.max(0.1, SETTINGS.sim_speed - 0.2);
        updateSpeedDisplay();
    };

    document.getElementById('speedUpBtn').onclick = () => {
        SETTINGS.sim_speed = Math.min(5.0, SETTINGS.sim_speed + 0.2);
        updateSpeedDisplay();
    };

    // Reset view functionality
    document.getElementById('resetViewBtn').onclick = () => {
        state.zoom = 1.0;
        state.pan = { x: 0.0, y: 0.0 };
    };

    // Initialize speed display
    updateSpeedDisplay();

    // Show mobile instructions on first visit
    let lastTap = 0;
    canvas.addEventListener('touchend', (e) => {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        if (tapLength < 500 && tapLength > 0) {
            // Double tap detected - reset view
            state.zoom = 1.0;
            state.pan = { x: 0.0, y: 0.0 };
        }
        lastTap = currentTime;
    });

    // Show mobile instructions for first-time mobile users
    if ('ontouchstart' in window && window.innerWidth <= 768) {
        const mobileInstructions = document.getElementById('mobileInstructions');
        mobileInstructions.style.display = 'block';
        setTimeout(() => {
            mobileInstructions.style.display = 'none';
        }, 5000);
    }

    resizeCanvas();
    initialize_simulation();
    requestAnimationFrame(gameLoop);

    });
    </script>
</body>
</html>